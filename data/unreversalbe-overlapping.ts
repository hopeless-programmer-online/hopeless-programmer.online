import { illustration, paragraph, sentence, link, section, article, note, list, ref, fig, neg, kw, cm, cpp, c, f, v, lt, js, emp, code } from "../classes/shortcuts";

const note_1 = '' // note(sentence(`У цій статті я буду вживати термін `, figurative(`перекриття`), ` замість звичного `, figurative(`приховування`), `. `));
const note_2 = '' // note(sentence(`Саме тому я називаю це перекриття `, figurative(`незворотним`), `. `));
const note_3 = '' // note(`Характерно те, що судячи зі всього розробники мови явно знали що роблять. `, `При спробі перекрити існуючий об'єкт виводиться попередження, що це недопустимо адже може спричинити неоднозначність. `);
const note_4 = '' // note(`Принаймні це можна назвати додатковими можливостями. `);
const note_5 = '' // note(`Варто зауважити і відсутність єдиного підходу до вирішення проблеми. `, `На відміну від часто вживаних засобів, типу звернення до полів об'єкта через крапку або виклик функції через круглі дужки, тут немає єдиного загальноприйнятого стандарту. `);
const note_6 = '' // note(`Це працює лише для впорядкованих областей, по типу блоків чи тіла функції. `, `Для просторів імен або класів цей підхід незастосовний. `);


const code_1  = illustration(
    sentence(`Змінна перекриває доступ до аргумента.`),
    js(...[
        [ kw(`function`), ` `, f(`f`), `(`, v(`x`), ` = `, lt(`1`), `) {` ],
        [ `    `, kw(`var`), ` `, v(`x`), ` = `, lt(`2`), `;` ],
        [ `    ` ],
        [ `    `, f(`print`), `(`, v(`x`), `);   `, cm(`// 2`) ],
        [ `    `, f(`print`), `(`, v(`???`), `); `, cm(`// як нам отримати х = 1?`) ],
        [ `}` ],
    ]),
)
const code_2  = illustration(
    `В C# спроба перекрити змінну приведе до помилки.`,
    code(`C#`, ...[
        [ c(`int`), ` `, v(`x`), ` = `, lt(`5`), `;` ],
        [ `...` ],
        [ `{` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`10`), `; `, cm(`// помилка`) ],
        [ `}` ],
    ]),
)
const code_3  = illustration(
    `Зворотне перекриття поля класу аргументом в C#.`,
    code(`C#`, ...[
        [ kw(`class`), ` `, c(`X`), ` {` ],
        [ `    `, c(`int`), ` `, v(`x`), `;` ],
        [ `    ` ],
        [ `    `, kw(`public`), ` `, c(`void`), ` `, f(`F`), `(`, c(`int`), ` `, v(`x`), `)` ],
        [ `    {` ],
        [ `        `, f(`print`), `(`, v(`x`), `);      `, cm(`// аргумент`) ],
        [ `        `, f(`print`), `(`, kw(`this`), `.`, v(`x`), `); `, cm(`// поле класу`) ],
        [ `    }` ],
        [ `}` ],
    ]),
)
const code_4  = illustration(
    sentence(`Звернення до глобального об'єкта в С++ за допомогою оператора `, cpp(`::`), `.`),
    code(`C++`, ...[
        [ c(`int`), ` `, v(`x`), ` = `, lt(`5`), `;` ],
        [ `` ],
        [ c(`void`), ` `, f(`f`), `() {` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`10`), `;` ],
        [ `    ` ],
        [ `    `, f(`print`), `(::`, v(`x`), `); `, cm(`// 5`) ],
        [ `}` ],
    ]),
)
const code_5  = illustration(
    `Робота з глобальною змінною в Python.`,
    code(`Python`, ...[
        [ v(`x`), ` = `, lt(`5`) ],
        [ `` ],
        [ kw(`def`), ` `, f(`f`), `():` ],
        [ `  `, kw(`global`), ` `, v(`x`) ],
        [ `  ` ],
        [ `  `, v(`x`), ` = `, lt(`10`) ],
        [ `` ],
        [ f(`f`), `()` ],
        [ `` ],
        [ f(`print`), `(`, v(`x`), `) `, cm(`# 10`) ],
    ]),
)
const code_6  = illustration(
    `Звернення через глобальний об'єкт в JavaScript.`,
    js( ...[
        [ kw(`var`), ` `, v(`x`), ` = `, lt(`5`), `;` ],
        [ `` ],
        [ kw(`function`), ` `, f(`f`), `() {` ],
        [ `    `, kw(`var`), ` `, v(`x`), ` = `, lt(`10`), `;` ],
        [ `    ` ],
        [ `    `, v(`console`), `.`, v(`log`), `(`, v(`x`), `);        `, cm(`// 10`) ],
        [ `    `, v(`console`), `.`, v(`log`), `(`, v(`global`), `.`, v(`x`), `); `, cm(`// 5`) ],
        [ `}` ],
        [ `` ],
        [ f(`f`), `();` ],
    ]),
)
const code_7  = illustration(
    sentence(`Оператор `, cpp(`::`), ` не спрацює для змінної `, cpp(v(`х`)), ` зі значенням `, cpp(lt(`2`)), `.`),
    code(`C++`, ...[
        [ c(`int`), ` `, v(`x`), ` = `, lt(`1`), `;` ],
        [ `` ],
        [ c(`void`), ` `, f(`f`), `()` ],
        [ `{` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`2`), `;` ],
        [ `    ` ],
        [ `    {` ],
        [ `        `, c(`int`), ` `, v(`x`), ` = `, lt(`3`), `` ],
        [ `        ` ],
        [ `        `, f(`print`), `(`, v(`x`), `);   `, cm(`// 3`) ],
        [ `        `, f(`print`), `(::`, v(`x`), `); `, cm(`// 1`) ],
        [ `        `, f(`print`), `(???); `, cm(`// 2?`) ],
        [ `    }` ],
        [ `}` ],
    ]),
)
const code_8  = illustration(
    `Звернення в порядку оголошення. `,
    code(`C++`, ...[
        [ c(`int`), ` `, v(`x`), ` = `, lt(`1`), `;` ],
        [ `` ],
        [ `{` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`2`), `;` ],
        [ `    ` ],
        [ `    {` ],
        [ `        `, c(`int`), ` `, v(`x`), ` = `, lt(`3`), `` ],
        [ `        ` ],
        [ `        `, f(`print`), `(`, v(`x`), `);       `, cm(`// 3`) ],
        [ `        `, f(`print`), `(../`, v(`x`), `);    `, cm(`// 2`) ],
        [ `        `, f(`print`), `(../../`, v(`x`), `); `, cm(`// 1`) ],
        [ `    }` ],
        [ `}` ],
    ]),
)
const code_9  = illustration(
    `Звернення до послідовно оголошених об'єктів в межах однієї області.`,
    code(`C++`, ...[
        [ c(`int`), ` `, v(`x`), ` = `, lt(`1`), `;` ],
        [ c(`int`), ` `, v(`x`), ` = `, lt(`2`), `;` ],
        [ c(`int`), ` `, v(`x`), ` = `, lt(`3`), `;` ],
        [ `` ],
        [ f(`print`), `(`, v(`x`), `);       `, cm(`// 3`) ],
        [ f(`print`), `(../`, v(`x`), `);    `, cm(`// 2`) ],
        [ f(`print`), `(../../`, v(`x`), `); `, cm(`// 1`) ],
    ]),
)
const code_10 = illustration(
    `Звернення до перекритих полів в С++.`,
    code(`C++`, ...[
        [ kw(`struct`), ` `, c(`A`) ],
        [ `{` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`1`), `;` ],
        [ `};` ],
        [ `` ],
        [ kw(`struct`), ` `, c(`B`), `: `, kw(`public`), ` `, c(`A`) ],
        [ `{` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`2`), `;` ],
        [ `    ` ],
        [ `    `, c(`void`), ` `, f(`F`), `()` ],
        [ `    {` ],
        [ `        `, f(`print`), `(`, c(`A`), `::`, v(`x`), `); `, cm(`// 1`) ],
        [ `        `, f(`print`), `(`, v(`x`), `);    `, cm(`// 2`) ],
        [ `    }` ],
        [ `};` ],
    ]),
)
const code_11 = illustration(
    `Звернення до перекритих аргументів функції.`,
    code(`C++`, ...[
        [ c(`void`), ` `, f(`f`), `(`, c(`int`), ` `, v(`x`), ` = `, lt(`1`), `)` ],
        [ `{` ],
        [ `    `, c(`int`), ` `, v(`x`), ` = `, lt(`2`), `;` ],
        [ `    ` ],
        [ `    `, f(`print`), `(`, v(`x`), `);   `, cm(`// 2`) ],
        [ `    `, f(`print`), `(`, f(`f`), `.`, v(`x`), `); `, cm(`// 1`) ],
        [ `}` ],
    ]),
)
const code_12 = illustration(
    `Звернення до перекритої змінної циклу.`,
    code(`C++`, ...[
        [ kw(`for`), ` `, v(`row`), ` (`, c(`int`), ` `, v(`index`), ` = `, lt(`0`), `; `, v(`index`), ` < `, lt(`10`), `; ++`, v(`index`), `)` ],
        [ `{` ],
        [ `    `, kw(`for`), ` `, v(`column`), ` (`, c(`int`), ` `, v(`index`), ` = `, lt(`0`), `; `, v(`index`), ` < `, lt(`10`), `; ++`, v(`index`), `)` ],
        [ `    {` ],
        [ `        `, f(`print`), `( `, v(`matrix`), `[`, v(`row`), `.`, v(`index`), `][`, v(`column`), `.`, v(`index`), `] );` ],
        [ `    }` ],
        [ `}` ],
    ]),
)
const code_13 = illustration(
    sentence(`Звернення до інструкції `, cpp(kw(`break`)), ` зовнішнього циклу.`),
    code(`C++`, ...[
        [ kw(`for`), ` `, v(`outer`), ` (`, c(`int`), ` `, v(`i`), ` = `, lt(`0`), `; `, v(`i`), ` < `, lt(`10`), `; ++`, v(`i`), `)` ],
        [ `{` ],
        [ `    `, kw(`for`), ` `, v(`inner`), ` (`, c(`int`), ` `, v(`j`), ` = `, lt(`0`), `; `, v(`j`), ` < `, lt(`10`), `; ++`, v(`j`), `)` ],
        [ `    {` ],
        [ `        `, v(`outer`), `.`, kw(`break`), `; `, cm(`// вихід з зовнішнього циклу`) ],
        [ `    }` ],
        [ `}` ],
    ]),
)

export default article([ `Думки вголос. `, `Незворотне перекриття ідентифікаторів. ` ], ...[
    section(``, ...[
        paragraph(...[
            sentence(`Явище `, fig(`перекриття`), note_1, ` (`, fig(`overlapping`), `) ідентифікаторів відоме ще з часів перших мов програмування. `),
            sentence(`Мене турбує той факт що подібна проблема дожила до наших днів і зустрічається майже в кожній сучасній мові. `),
            sentence(`Я вирішив присвятити цій темі окрему статтю, в якій і спробую викласти свої погляди на ситуацію. `),
        ]),
    ]),
    section(`Проблематика`, ...[
        code_1,
        paragraph(...[
            sentence(`В приведеному коді (див. `, code_1, `) змінна `, js(v(`x`)), ` перекриває аргумент `, js(v(`x`)), `. `),
            sentence(`Після її оголошення попередній об'єкт втрачається `, emp(`назавжди`), note_2, `. `),
            sentence(`І це проблема, адже однакові назви можуть бути зовсім не випадковими. `),
            sentence(`Якщо подібне іменування буде нести деяке `, fig(`корисне навантаження`), `, то механізм перекриття стане перешкодою. `),
        ]),
        paragraph(...[
            `Але чому не передбачено механізму для звернення до перекритої змінної? `,
            `Чому взагалі перекриття дозволене? `,
            `В такому вигляді від нього немає користі, адже змінні все одно доведеться перейменовувати якщо знадобиться одночасний доступ до обох. `,
        ]),
    ]),
    section(`Життя без перекриття`, ...[
        paragraph(...[
            `Існують мови позбавлені подібної вади. `,
            `Використана в них стратегія не розвиває цей механізм, а позбувається від нього. `,
            sentence(`Наприклад, в `, link(`мові програмування C#`, `https://uk.wikipedia.org/wiki/C_Sharp`), ` перекриття заборонене`, note_3, `. `),
            sentence(`Змінні повинні оголошуватись так, щоб до них можна було звернутись з будь-якого місця в програмі (див. `, code_2, `)). `),
            sentence(`При цьому зберігається можливість перекривати поля класу при наслідуванні, а також аргументами функцій. `),
            sentence(`Це не суперечить правилам, неоднозначності в цих випадках завжди можна вирішити (див. `, code_3, `). `),
            sentence(`Це дуже важливий момент, адже таке `, fig(`зворотне`), ` перекриття не несе в собі явних недоліків, лише переваги`, note_4, `. `),
        ]),
        code_2,
        code_3,
    ]),
    section(`Часткові рішення`, ...[
        paragraph(...[
            sentence(`В `, link(`JavaScript`, `https://uk.wikipedia.org/wiki/JavaScript`), `, `, link(`С++`, `https://uk.wikipedia.org/wiki/C%2B%2B`), ` та `, link(`Python`, `https://uk.wikipedia.org/wiki/Python`), ` проблему перекриття вирішили частково. `),
            sentence(`Перекриття локальних змінних залишається незворотнім процесом. `),
            sentence(`А от звернення до глобальних об'єктів можна відрізнити за допомогою спеціальних операторів. `),
            sentence(`В С++ для цього використовується оператор `, js(`::`), ` (див. `, code_4, `). `),
            sentence(`Щоб виконати таке в Python змінна повинна бути оголошена через ключове слово `, js(kw(`global`)), ` (див. `, code_5, `). `),
            sentence(`А в JavaScript `, js(kw(`global`)), ` виступає спеціальним об'єктом, який містить в собі усі `, emp(`глобальні`), ` об'єкти в якості полів (див. `, code_6, `). `),
        ]),
        code_4,
        code_5,
        code_6,
        paragraph(...[
            sentence(`Перелічені приклади ілюструють намагання боротись з цією проблемою. `),
            sentence(`Але задіяні в них механізми розраховані лише на один рівень вкладення і перестають працювати для вкладень більших порядків (див. `, code_7, `). `),
            sentence(`Можливо саме через невелику актуальність подібних проблем цей підхід не був розвинутий`, note_5, `. `),
            sentence(`Але ніколи не пізно це виправити! `),
        ]),
        code_7,
    ]),
    section(`Звернення в порядку оголошення`, ...[
        paragraph(...[
            sentence(`Одна зі стратегій - це звернення до перекритих змінних через спеціальний префікс або ключове слово. `),
            sentence(`Причому зі збільшенням порядку перекриття буде збільшуватись і число таких префіксів (див. `, code_8, `). `),
            sentence(`Такий підхід цілком природний і добре відомий з роботи з файловою системою. `),
            sentence(`Цікаво те, що з такими можливостями взагалі немає сенсу вводити обмеження на унікальність ідентифікатора в межах області`, note_6, ` (див. `, code_9, `). `),
        ]),
        code_8,
        code_9,
    ]),
    section(`Звернення через зовнішню область`, ...[
        paragraph(...[
            sentence(`Існує цікавий механізм, який дозволяє боротись з перекриттям полів при наслідуванні. `),
            sentence(`Ідея в тому, що звернення відбувається не напряму, а через ім'я відповідного класу (див. `, code_10, `). `),
            sentence(`Такий підхід досить розповсюджений і його можна було б розвинути. `),
            sentence(`Наприклад, аргументи функції можуть бути отримані через `, emp(`однойменний`), ` префікс (див. `, code_11, `). `),
        ]),
        code_10,
        code_11,
        paragraph(...[
            sentence(`Те саме можна застосувати і до циклів, якщо дозволити їх іменування (див. `, code_12, `). `),
            sentence(`Окремо варто зазначити, що це також вирішило б проблему виходу з декількох циклів (див. `, code_13, `), оскільки команда `, js(kw(`break`)), ` теж виступає заручником механізму перекриття. `),
        ]),
        code_12,
        code_13,
    ]),
    section(`Висновки`, ...[
        paragraph(...[
            sentence(`Існуюча реалізація перекриття обмежена і позбавлена переваг. `),
            sentence(`Але її все ж можна розвинути, особливо приймаючи до уваги існуючі рішення схожих проблем. `),
            sentence(`Запропоновані у цій статті підходи інтуїтивно зрозумілі та мають відносно просту реалізацію. `),
            sentence(`В залежності від дизайну мови їх можна використовувати не лише окремо, але й комбіновано. `),
        ]),
    ]),
])
