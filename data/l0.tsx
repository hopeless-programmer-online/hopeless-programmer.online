import React from 'react'
import { article, c, cm, code, cs, emp, f, fig, illustration, js, jsx, kw, link, lt, neg, note, paragraph, py, quote, section, sentence, v, l0, cpp, lts, comparison, ts } from '../classes/shortcuts'

const poc = `https://en.wikipedia.org/wiki/Proof_of_concept`
const cps = `https://en.wikipedia.org/wiki/Continuation-passing_style`
const callback = `https://uk.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)`
const sugar = `https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D1%86%D1%83%D0%BA%D0%BE%D1%80`
const closure = `https://uk.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D0%B8%D0%BA%D0%B0%D0%BD%D0%BD%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)`
const first_class = `https://uk.wikipedia.org/wiki/%D0%9E%D0%B1%27%D1%94%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D1%88%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%83`

class L0 extends React.Component {
    public render() {
        return (
            <i style={{ fontWeight : `bold`, color : `crimson`, fontFamily : `Helvetica` }}>L<sup>0</sup></i>
        )
    }
}

const note_1 = note(
    sentence(`Мені не подобається термін `, fig(`типізація`), `, який часто вживають в мережі та літературі. `),
    sentence(`Натомість, я вживатиму термін `, fig(`контроль типів`), `. `),
    sentence(`Таким чином, наприклад, `, fig(`статичний контроль типів`), ` тут можна вважати `, fig(`статичною типізацією`), `, а `, fig(`програмований контроль типів`), ` - `, fig(`програмованою типізацією`), `. `),
)

export default  article([ sentence(`Мова програмування `, L0, `. `), sentence(`Програмований контроль типів. `) ], {}, ...[
    section(sentence(`Що таке `, L0, `? `), ...[
        paragraph(...[
            sentence(L0, ` - це невелика експериментальна мова програмування створена мною у 2021-у році. `),
            sentence(`Вона не є настільки ж повноцінною мовою, як, наприклад, JavaScript чи C: писати програми на ній складно. `),
            sentence(`Але це від неї і не вимагається, адже `, L0, ` створювалась винятково в якості прикладу доведення концепції програмованого контролю типів. `),
            sentence(`Далі у цій статті я поясню, що саме маю на увазі під цією концепцією, а також познайомлю читачів з самою мовою. `),
        ]),
        paragraph(...[
            sentence(`Поширений сьогодні підхід до контролю типів`, note_1, ` полягає у накладанні обмежень на змінні чи аргументи функцій. `),
            sentence(`Ці обмеження описуються за допомогою фіксованого набору правил, таких як числа, стрічки чи структури. `),
            sentence(`На відміну від цього програмований контроль передбачає, що ці обмеження реалізуються шляхом написання програм. `),
            sentence(`Іншими словами, замість вказування типів ми створюємо програму, здатну проаналізувати власну структуру. `),
            sentence(`А оскільки, як відомо, запрограмувати можливо все що завгодно, програмований контроль може бути розв'язком невирішуваних проблем для класичних підходів. `),
        ]),
        illustration(``, comparison(
            js(...[
                [ `function add(x, y) {` ],
                [ `    return x + y` ],
                [ `}` ],
            ]),
            ts(...[
                [ `function add(x : number, y : number) : number {` ],
                [ `    return x + y` ],
                [ `}` ],
            ]),
        )),
        paragraph(...[
            sentence(`Мова `, L0, ` була спроектована таким чином, щоб максимально спростити такий аналіз і показати, що програмований підхід принципово можливий. `),
            sentence(`У ній немає зручних структур які полегшують написання коду але, як ми побачимо далі разом з ними відсутня й потреба в складному алгоритмі перевірки. `),
            sentence(`Це не дозволяє використовувати `, L0, ` в повсякденному житті, але її приклад може показати, як контроль типів міг би бути реалізований в майбутніх мовах. `),
            sentence(`Гнучкіший, надійніший, програмований. `),
        ]),
    ]),
    section(`Проблема контролю типів. `, ...[
        paragraph(...[
            sentence(`Класичний контроль типів не є повноцінним. `),
            sentence(`З його допомогою неможливо описати `, fig(`будь-які`), ` обмеження: лише ті, які передбачені фіксованим набором правил та їх комбінацій. `),
            sentence(`Наприклад, реалізуючи функцію ділення ми не можемо гарантувати, що дільник не буде рівний нулю: для цього просто не існує відповідного правила. `),
            sentence(`Може здатись, що достатньо просто додати таке правило в мову, але це не вирішить проблему в цілому. `),
            sentence(`По-перше, конкретне правило спрацює лише для обмеженого набору випадків. `),
            sentence(`Для решти доведеться вводити нові правила, яких в загальному може бути нескінченно багато. `),
            sentence(`По-друге, це вимагатиме внесення змін в саму мову - в її транслятор - що по суті рівноцінне створенню нової мови. `),
            sentence(`Ми не створюємо нову мову, коли потрібно написати нову програму. `),
            sentence(`Чому тоді ми повинні створювати нову мову, коли потрібно розширити контроль? `),
        ]),
        illustration(``, ts(...[
            [ `// немає гарантії, що y != 0` ],
            [ `function divide(x : number, y : number) {` ],
            [ `    return x / y` ],
            [ `}` ],
        ])),
        paragraph(...[
            sentence(`Існує безліч інших прикладів які роблять підхід додавання правил `, fig(`за потреби`), ` неефективним. `),
            sentence(`Наприклад, не існує типу для опису відсортованого масиву, навіть при тому що в програмуванні сортування є досить поширеною операцією. `),
            sentence(`Без такого контролю ми не лише не можемо перевірити, що правильно реалізували сортування, але й не можемо гарантувати передачу такого масиву в алгоритми які покладаються на сортування. `),
            sentence(`Для інтерфейсів роботи з файлами ми не можемо гарантувати, що перед методами `, ts(`read()`), ` та `, ts(`write()`), ` був викликаний `, ts(`open()`), ` і не був викликаний `, ts(`close()`), `. `),
            // sentence(`Деякі з цих проблем ми вирішуємо у інший спосіб, просто тому, що сьогодні контроль типів не може тут нічим зарадити. `),
            sentence(`Навіть якщо ввести нові типи для цих проблем знайдуться сотні інших, яким доведеться чекати на власні типи. `),
        ]),
        illustration(``, ts(...[
            [ `// тип Sorted гарантує, що повернений масив відсортований` ],
            [ `function mySort(array : number[]) : Sorted<number> {` ],
            [ `    // реалізація` ],
            [ `}` ],
            [ `` ],
            [ `// тип Sorted гарантує, що переданий масив відсортований` ],
            [ `function binarySearch(x : number, array : Sorted<number>) {` ],
            [ `    // ...` ],
            [ `}` ],
        ])),
        illustration(``, ts(...[
            [ `file.open()` ],
            [ `` ],
            [ `file.read() // ok` ],
            [ `file.write() // ok` ],
            [ `` ],
            [ `file.close()` ],
            [ `` ],
            [ `file.read() // помилка, файл не відкрито` ],
        ])),
        paragraph(...[
            sentence(`Все зводиться до того, що з наявною системою типів ми не можемо описати `, fig(`будь-що`), `. `),
            sentence(`Навіть якщо ми знаємо як перевірити чи масив відсортовано, ми не можемо записати це у вигляді типу в TypeScript або C++. `),
            sentence(`Це дуже схоже на те, як неможливо написати `, fig(`будь-яку`), ` програму на SQL або HTML: обидві мови є дуже обмежено застосовними та декларативними`, note(`А друга так взагалі не є мовою програмування. `), `. `),
            sentence(`Вони призначені для опису того `, fig(`що`), ` ми хочемо отримати, але не `, fig(`яким чином`), `. `),
            sentence(`З їх допомогою неможливо записати алгоритм, послідовність дій. `),
            sentence(`Такі ж обмежені декларативні мови ми використовуємо сьогодні для опису типів. `),
        ]),
        paragraph(...[
            sentence(`Тому, можливо, замість обмеженого набору типів є сенс використовувати саме програмований підхід. `),
            sentence(`Якби для контролю типів необхідно було написати програму яка його реалізує, це б `, fig(`розв'язало руки`), ` розробникам. `),
            sentence(`Контроль перестав би залежати від мови і перейшов би в зону відповідальності користувацьких бібліотек. `),
            sentence(`Для перевірки того як це могло б виглядати і створювалась  `, L0, `. `),
        ]),
    ]),
    section(sentence(`Мова програмування `, L0, `. `), ...[
        paragraph(...[
            sentence(L0, ` вкрай мінімалістична мова: весь її синтаксис складається лише з двох конструкцій`, note(`Окрім коментарів, які я чомусь вирішив не враховувати. `), `. `),
            sentence(`Її основними виконуваними одиницями є `, fig(`програми`), `, які можна оголошувати та викликати. `),
            sentence(`Програми дуже схожі на функції з інших мов: вони приймають аргументи, повертають результати та послідовно виконують команди. `),
            sentence(`Також як і функції в багатьох мовах, програми в `, L0, ` є об'єктами першого класу: їх можна передавати в якості аргументів та повертати. `),
        ]),
        illustration(``, l0(...[
            [ `; оголошення програми` ],
            [ `main() {` ],
            [ `    ; тіло програми` ],
            [ `    print("hello, world!")` ],
            [ `}` ],
            [ `` ],
            [ `; виклик програми` ],
            [ `main()` ],
        ])),
        illustration(``, l0(...[
            [ `; оголошення програми` ],
            [ `main(callback) {` ],
            [ `    ; виклик програми-аргументу` ],
            [ `    callback()` ],
            [ `}` ],
            [ `callback() {` ],
            [ `    print("hello, callback!")` ],
            [ `}` ],
            [ `` ],
            [ `; передача програми в якості аргументу` ],
            [ `main(callback)` ],
        ])),
        paragraph(...[
            sentence(`Основна відмінність програм від функцій полягає в механізмі повернення, який `, L0, ` реалізує через передачу продовжень. `),
            sentence(`Безпосередньо перед викликом програми увесь наступний код загортається в програму-продовження, яка передається першим неявним аргументом `, l0(kw(`super`)), `. `),
            sentence(`Далі `, l0([ kw(`super`), `()` ]), ` можна використовувати для повернення як і `, js(kw(`return`)),` в інших мовах, але виглядати і працювати він буде саме як виклик (тому що це і є виклик). `),
            sentence(`Усі змінні передані в `, l0([ kw(`super`), `()` ]), ` будуть повернуті як результат на тій стороні, а саму змінну `, l0(kw(`super`)), ` можна зберегти, передати в якості аргументу, повернути або навіть викликати кілька разів поспіль. `),
            sentence(`Таким чином, повернення в `, L0, ` це лише синтаксичний цукор навколо передачі продовження. `),
        ]),
        illustration(``, comparison(
            l0(...[
                [ `; оголошення програми` ],
                [ `program(x, y) {` ],
                [ `    super(x, y)` ],
                [ `}` ],
                [ `` ],
                [ `; виклик програми` ],
                [ `u, v : program(1, 2)` ],
                [ `` ],
                [ `; вивід результату` ],
                [ `print(u, v)` ],
            ]),
            l0(...[
                [ `; оголошення програми` ],
                [ `program(super, x, y) {` ],
                [ `    super(x, y)` ],
                [ `}` ],
                [ `` ],
                [ `; оголошення продовження` ],
                [ `super(u, v) {` ],
                [ `    ; вивід результату` ],
                [ `    print(u, v)` ],
                [ `}` ],
                [ `` ],
                [ `; виклик програми, передача продовження` ],
                [ `program(super, 1, 2)` ],
            ]),
        )),
        paragraph(...[
            sentence(`Під час свого оголошення програма замикає усі змінні оголошені до неї`, note(`враховуючи посилання на саму себе`), `, даючи можливість звернутись до них під час виклику. `),
            sentence(`Замкнені змінні передаються у вигляді неявних аргументів, які `, L0, ` збереже у спеціальному сховищі під час оголошення та відновить безпосередньо перед викликом. `),
            sentence(`Оскільки продовження також є програмами, такий же підхід застосовується і під час їхнього оголошення. `),
            sentence(`Якщо врахувати неявний аргумент `, l0(kw(`super`)), ` то стає цілком зрозуміло, що кожна програма є незалежною від усіх зовнішніх змінних і працює винятково зі своїми аргументами. `),
            sentence(`Замикання в `, L0, ` лише синтаксичний цукор. `),
        ]),
        illustration(``, l0(...[
            [ `; якась змінна` ],
            [ `value : get value()` ],
            [ `` ],
            [ `; оголошення програми` ],
            [ `my program() {` ],
            [ `    ; тут можна звернутись до value` ],
            [ `    super(value)` ],
            [ `}` ],
        ])),
        illustration(``, comparison(
            l0(...[
                [ `; зовнішня змінна` ],
                [ `x : get x()` ],
                [ `` ],
                [ `; оголошення програми` ],
                [ `my program(y) {` ],
                [ `    super(x, y)` ],
                [ `}` ],
                [ `` ],
                [ `; виклик програми` ],
                [ `my program(2)` ],
            ]),
            l0(...[
                [ `; зовнішня змінна` ],
                [ `x : get x()` ],
                [ `` ],
                [ `; оголошення програми` ],
                [ `; x тепер явний аргумент` ],
                [ `my program(x, y) {` ],
                [ `    super(x, y)` ],
                [ `}` ],
                [ `` ],
                [ `; виклик програми` ],
                [ `my program(x, 2)` ],
            ]),
        )),
        paragraph(...[
            sentence(`Остання важлива особливість `, L0, ` полягає в тому, що оголошення програми насправді теж є викликом. `),
            sentence(`Для цього використовується спеціальна програма зв'язування - `, l0([ kw(`bind`), `()` ]), `. `),
            sentence(`Принцип її роботи схожий до `, js([ c(`Function`), `.`, v(`prototype`), `.`, f(`bind`), `()` ]), ` з JavaScript: вона заповнює частину аргументів програми і повертає нову. `),
            sentence(`Але на відміну від JavaScript `, l0(kw(`bind`)), ` працює не з вже створеною програмою, а з її `, fig(`шаблоном`), `. `),
            sentence(`Шаблон містить `, emp(`вичерпну`), ` інформацію про те з якими аргументами працюватиме програма, куди передасть керування та які аргументи і в якому порядку потрібно передати. `),
        ]),
        paragraph(...[
            sentence(l0(kw(`bind`)), ` поєднує шаблон зі сховищем неявних аргументів, результатом чого і є програма. `),
            sentence(`Але оскільки йому потрібне продовження для повернення результату - для створення якого потрібен ще один виклик `, l0(kw(`bind`)), ` - він одночасно працює з двома шаблонами: для цільової програми та продовження. `),
            sentence(`Таким чином оголошення програми в `, L0, ` є викликом, під час якого шаблон зв'язується з неявними аргументами. `),
            sentence(`На основі цього працює як звичайне оголошення програми, так і оголошення продовження для звичайного виклику. `),
        ]),
        illustration(``, l0(...[
            [ `; #continuation - незв'язане продовження` ],
            [ `; #target - незв'язана цільова програма` ],
            [ `; arg0-N - неявні аргументи` ],
            [ `bind(#continuation, #target, arg0, arg1, ..., argN) {` ],
            [ `    ; тут відбувається магія зв'язування` ],
            [ `    ; target - зв'язана цільова програма` ],
            [ `    ; arg0, arg1 ... argN збережені в сховищі target` ],
            [ `    ; передача керування в продовження` ],
            [ `    #continuation(arg0, arg1, ..., argN, target)` ],
            [ `}` ],
        ])),
        paragraph(...[
            sentence(`На такому рівні програми втрачають свою звичну структуру і перетворюються на ланцюжок послідовних викликів - `, fig(`інструкцій`), `. `),
            sentence(`Кожна така інструкція виконує лише один крок: вказує наступну інструкцію та порядок передачі аргументів. `),
            sentence(`В результаті програма перетворюється на аналог графу, до структури якого можна звернутись через спеціальні механізми `, L0, `. `),
            sentence(``),
        ]),
    ]),
    section(``, ...[
        paragraph(...[
            sentence(``),
        ]),
        paragraph(...[
            sentence(``),
        ]),
    ]),
])
