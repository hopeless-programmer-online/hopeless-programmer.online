import React from 'react'
import { article, c, cm, code, cs, emp, f, fig, illustration, js, jsx, kw, link, lt, neg, note, paragraph, py, quote, section, sentence, v, l0, cpp, lts } from '../classes/shortcuts'

class L0 extends React.Component {
    public render() {
        return (
            <i style={{ fontWeight : `bold`, color : `crimson`, fontFamily : `Helvetica` }}>L<sup>0</sup></i>
        )
    }
}

const braces = note(`Так, саме тому ці пари дужок не можна використовувати в іменах. `)

const example_1 = illustration(``, l0(...[
    [ `my first program (x, y, z) {` ],
    [ `    ... commands here ...` ],
    [ `}` ],
]))
const example_2 = illustration(``, l0(...[
    [ `my program () {` ],
    [ `    super()` ],
    [ `}` ],
]))
const example_3 = illustration(``, l0(...[
    [ `outer (x) {` ],
    [ `    inner () {` ],
    [ `        print(x)` ],
    [ `    }` ],
    [ `}` ],
]))
const example_4 = illustration(``, l0(...[
    [ `outer () {` ],
    [ `    inner () {` ],
    [ `        /super()` ],
    [ `    }` ],
    [ `}` ],
]))
const example_5 = illustration(``, l0(...[
    [ `f (x, x, x) {` ],
    [ `    print(x)   ; 3` ],
    [ `    print(/x)  ; 2` ],
    [ `    print(//x) ; 1` ],
    [ `}` ],
    [ `` ],
    [ `f(1, 2, 3)` ],
]))
const example_6 = illustration(``, l0(...[
    [ `f () {` ],
    [ `    super(1, 2)` ],
    [ `}` ],
    [ `` ],
    [ `u, v, w : f()` ],
    [ `` ],
    [ `print(u) ; 1` ],
    [ `print(v) ; 2` ],
    [ `print(w) ; nothing` ],
]))

export default  article(sentence(`Мова програмування `, L0, `. `), {}, ...[
    section(sentence(`Що таке `, L0, `? `), ...[
        paragraph(...[
            sentence(L0, ` - це мініатюрна мова програмування створена мною в дослідницьких цілях. `),
            sentence(`Вона складається лише з трьох типів конструкцій та використовує передачі продовжень замість звичних повернень. `),
            sentence(`Такий дизайн зовсім не випадковий, адже основною метою створення `, L0, ` було дослідження меж застосовності користувацьких бібліотек коду. `),
            sentence(`Зокрема, мені було цікаво чи можливо в таких `, fig(`тісних`), ` та обмежених умовах проводити автоматизовану оптимізацію, кодогенерацію та статичний аналіз засобами самої мови, без втручання в транслятор. `),
            sentence(`Спойлер: можливо. `),
            sentence(`Але перед обговоренням усього цього є сенс, власне, познайомитись з мовою. `),
        ]),
        illustration('', l0(...[
            [ f(`print`), `(`, lt(`"hello, world!"`), `)` ],
        ]))
    ]),
    section(sentence(`Імена та програми. `), ...[
        paragraph(...[
            sentence(`Усього `, L0, ` передбачає три типи конструкцій: імена, оголошення програм та виклики. `),
            sentence(`Імена складаються з будь-яких символів за винятком `, l0(`,:;(){}[]`), `. `),
            sentence(`Пропуски та інші спеціальні символи теж дозволені, тобто можливі імена на кшталт `, l0(`my first program`), ` або `, l0(`!@#$ placeholder $#@!`), `. `),
            sentence(`Важливо, що пропуски між частинами імені скорочуються до одного, тому імена `, l0(`name #1`), ` та `, l0(`name     #2`), ` будуть вважатись ідентичними. `),
            sentence(`Також мова чутлива до регістру, тому імена `, l0(`abc`), `, `, l0(`ABC`), ` та `, l0(`aBc`), ` будуть вважатись різними. `),
        ]),
        paragraph(...[
            sentence(`Імена також можуть складатись з цифр або лапок. `),
            sentence(`При цьому та частина імені яка починається з подвійних лапок (`, l0(lts(`"`)), `) повинна рано чи пізно завершуватись ними. `),
            sentence(`Всередині лапок працює екранування за допомогою оберненої косої риски (`, l0(`\\`), `), тому якщо необхідно додати лапки всередину такої `, fig(`стрічки`), ` то це можна зробити ось так: `, l0(lts(`"abc\\"xyz"`)), `. `),
            sentence(`Також імена в `, L0, ` можуть складатись зі змішаних частин, наприклад `, l0([ `my `, lt(`"string"`) ]), ` або `, l0([ lt(`"this"`), ` is `, lt(`"my"`), ` text` ]), `. `),
            sentence(``),
        ]),
        paragraph(...[
            sentence(`Програми - це другий різновид конструкцій в `, L0, `. `),
            sentence(`Вони майже ідентичні до функцій з інших мов: зокрема, вони можуть приймати параметри і повертати значення. `),
            sentence(`Оголосити програму можна записавши її ім'я, список параметрів в круглих дужках (`, l0(`()`), `) та список команд в фігурних (`, l0(`{}`), `)`, braces, ` (див. `, example_1, `). `),
            sentence(`Програми в `, L0, ` є об'єктами першого класу: їх можна зберігати, повертати або приймати в якості аргументів. `),
        ]),
        example_1,
        paragraph(...[
            sentence(`Окрім звичайних параметрів кожна програма неявно отримує один додатковий - `, l0(kw(`super`)), `. `),
            sentence(`Він сам є програмою-продовженням і працює аналогічно до `, js(kw(`return`)), ` в інших мовах, тобто повертає керування в місце виклику (див. `, example_2, `). `),
            sentence(`Але на відміну від `, js(kw(`return`)), `, `, l0(kw(`super`)), `, будучи програмою, є об'єктом першого класу. `),
            sentence(`Це означає, що його теж можна зберігати, повертати або приймати в якості аргументу. `),
            sentence(`Ця особливість дуже відрізняє `, L0, ` від інших мов, тому ми ще поговоримо про неї згодом. `),
        ]),
        example_2,
        paragraph(...[
            sentence(`Програми можна оголошувати всередині інших програм. `),
            sentence(`При цьому внутрішні програми замикають усі імена до власного оголошення і можуть використовувати їх під час виклику (див. `, example_3, `). `),
            sentence(`Це стосується також і `, l0(kw(`super`)), ` зовнішньої програми, тобто в `, L0, ` можна виконати вихід з зовнішньої функції (див. `, example_4, `). `),
            sentence(`Але оскільки `, emp(`кожна`), ` функція неявно оголошує свій власний `, l0(kw(`super`)), ` необхідно додати до назви префікс `, l0(`/`), ` аби вказати що ми явно звертаємось до `, fig(`попереднього`), ` імені. `),
        ]),
        example_3,
        example_4,
        paragraph(...[
            sentence(`Останній приклад (див. `, example_4, `) показує, що `, L0, ` вміє боротись з перекриттям імен. `),
            sentence(`У будь якому місці програми можна оголосити ім'я яке вже існує, а звернення до попереднього імені буде здійснюватись з додаванням префіксу `, l0(`/`), ` (див. `, example_5, `). `),
            sentence(`Що більший рівень у перекриття то більше префіксів потрібно додавати. `),
            sentence(`Це гарантує як можливість перекрити будь яке ім'я, так і звернутись до будь якого з перекритих імен. `),
        ]),
        example_5,
        paragraph(...[
            sentence(`Після оголошення програми її можна викликати. `),
            sentence(`Виклик відбувається за допомогою запису круглих дужок після імені, всередині яких можна вказати імена аргументів. `),
            sentence(`Важливо, що `, L0, ` `, emp(`не`), ` підтримує складні аргументи на кшталт викликів інших функцій чи оголошень, передавати можна лише прості імена. `),
        ]),
        paragraph(...[
            sentence(`Після того як програма закінчить своє виконання вона поверне значення які були передані у відповідний `, l0(kw(`super`)), `. `),
            sentence(`Отримати їх можна записавши назви змінних разом з двокрапкою (`, l0(`:`), `) перед викликом (див. `, example_6, `). `),
            sentence(`Якщо повернутих значень буде менше ніж отриманих то відповідні змінні приймуть значення `, l0(kw(`nothing`)), `. `),
            sentence(``),
        ]),
        example_6,
    ]),
    section(``, ...[
        paragraph(...[
            sentence(``),
        ]),
    ]),
])
