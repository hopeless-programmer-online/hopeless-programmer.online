<?xml-stylesheet type="text/css" href="./rasterization.css" ?>
<svg
    version="1.1"
    xmlns="http://www.w3.org/2000/svg"
    width="600px"
    height="300px"
    style="background-color: whitesmoke"
>
    <svg
        name="vector"
        x="0"
        y="0"
        width="50%"
        height="100%"
    >
    </svg>
    <svg
        name="raster"
        x="50%"
        y="0"
        width="50%"
        height="100%"
    >
    </svg>
    <style>
        line.hp-class-delimiter {
            stroke : rgba(0,0,0,0.25);
            stroke-width : 1;
            stroke-dasharray : 2,2;
        }
        rect.hp-class-pixel {
            fill: black;
            stroke : gray;
            stroke-width : 1;
        }
        circle.hp-class-point {
            fill: red;
            stroke: black;
            stroke-width: 2;
        }
        circle.hp-class-point:hover {
            fill: black;
            stroke: orange;
            stroke-width: 2;
        }
        line.hp-class-line {
            stroke : orange;
            stroke-width : 1;
        }
    </style>
    <script>
        (() => {
const svg = document.currentScript.parentNode;
const vector = svg.querySelector(`svg[name="vector"]`);
const raster = svg.querySelector(`svg[name="raster"]`);

function circle(x, y) {
    const element = document.createElementNS(`http://www.w3.org/2000/svg`, `circle`);

    element.classList.add(`hp-class-point`);
    element.setAttribute(`cx`, x);
    element.setAttribute(`cy`, y);
    element.setAttribute(`r`, 5);

    vector.appendChild(element);

    return element;
}
function line(x1, y1, x2, y2) {
    const element = document.createElementNS(`http://www.w3.org/2000/svg`, `line`);

    element.classList.add(`hp-class-line`);
    element.setAttribute(`x1`, x1);
    element.setAttribute(`y1`, y1);
    element.setAttribute(`x2`, x2);
    element.setAttribute(`y2`, y2);

    vector.appendChild(element);

    return element;
}

class Subscription {
    constructor() {
        this.__subscribers = [];
    }

    Subscribe(subscriber) {
        this.__subscribers.push(subscriber);
    }
    Unsubscribe(subscriber) {
        const subscribers = this.__subscribers;
        const index = subscribers.indexOf(subscriber);

        if (index === -1) throw new Error; // @todo

        subscribers.splice(index, 1);
    }
    Notify(...values) {
        for (const subscriber of this.__subscribers) subscriber(...values);
    }
}
class Point {
    constructor({ X = 0, Y = 0 } = {}) {
        this.X = X;
        this.Y = Y;

        const element = circle(X, Y);

        this.element = element;
        this.Move = new Subscription;

        this.onMouseDown = this.OnMouseDown.bind(this);
        this.onMouseUp   = this.OnMouseUp.bind(this);
        this.onMouseMove = this.OnMouseMove.bind(this);

        element.addEventListener(`mousedown`, this.onMouseDown);
    }

    OnMouseDown() {
        this.element.removeEventListener(`mousedown`, this.onMouseDown);
        document.addEventListener(`mouseup`, this.onMouseUp);
        document.addEventListener(`mousemove`, this.onMouseMove);
    }
    OnMouseUp() {
        document.removeEventListener(`mouseup`, this.onMouseUp);
        document.removeEventListener(`mousemove`, this.onMouseMove);
        this.element.addEventListener(`mousedown`, this.onMouseDown);
    }
    OnMouseMove({ clientX, clientY }) {
        this.X = clientX;
        this.Y = clientY;

        const rect = vector.getBoundingClientRect();

        this.element.attributes.cx.value = clientX - rect.left;
        this.element.attributes.cy.value = clientY - rect.top;

        this.Move.Notify(this);
    }
}
class Line {
    constructor({ X1 = 0, Y1 = 0, X2 = 0, Y2 = 0 } = {}) {
        const l = line(X1, Y1, X2, Y2);
        const a = new Point({ X : X1, Y : Y1 });
        const b = new Point({ X : X2, Y : Y2 });
        const change = new Subscription;

        this.a = a;
        this.b = b;
        this.l = l;
        this.begin = { X : X1, Y : Y1 };
        this.end = { X : X2, Y : Y2 };
        this.X1 = X1;
        this.Y1 = Y1;
        this.X2 = X2;
        this.Y2 = Y2;
        this.Change = change;

        a.Move.Subscribe(({ X, Y }) =&gt; {
            this.X1 = X;
            this.Y1 = Y;

            l.setAttribute(`x1`, X);
            l.setAttribute(`y1`, Y);
            change.Notify(this);
        });
        b.Move.Subscribe(({ X, Y }) =&gt; {
            this.X2 = X;
            this.Y2 = Y;

            l.setAttribute(`x2`, X);
            l.setAttribute(`y2`, Y);
            change.Notify(this);
        });
    }
}

const points = [
    new Point({ X : 50, Y : 50 }),
    new Point({ X : 100, Y : 150 }),
];
const lines = [
    new Line({ X1 : 10, Y1 : 10, X2 : 70, Y2 : 180 }),
];

for (const point of points) point.Move.Subscribe(rasterize);
for (const line of lines) line.Change.Subscribe(rasterize);

// console.log(...points);

const pixels = [];
const pixelsX = 20;
const pixelsY = 20;
const sizeX = 300;
const sizeY = 300;

for (let x = 1; x &lt; pixelsX - 1; ++x) {
    const element = document.createElementNS(`http://www.w3.org/2000/svg`, `line`);

    element.classList.add(`hp-class-delimiter`);
    element.setAttribute(`x1`, `${x / (pixelsX - 1) * 100}%`);
    element.setAttribute(`y1`, `0%`);
    element.setAttribute(`x2`, `${x / (pixelsX - 1) * 100}%`);
    element.setAttribute(`y2`, `100%`);

    vector.appendChild(element);
}
for (let y = 1; y &lt; pixelsY - 1; ++y) {
    const element = document.createElementNS(`http://www.w3.org/2000/svg`, `line`);

    element.classList.add(`hp-class-delimiter`);
    element.setAttribute(`x1`, `0%`);
    element.setAttribute(`y1`, `${y / (pixelsY - 1) * 100}%`);
    element.setAttribute(`x2`, `100%`);
    element.setAttribute(`y2`, `${y / (pixelsY - 1) * 100}%`);

    vector.appendChild(element);
}
for (let x = 0; x &lt; pixelsX; ++x) {
    pixels[x] = [];

    for (let y = 0; y &lt; pixelsY; ++y) {
        const pixel = document.createElementNS(`http://www.w3.org/2000/svg`, `rect`);

        pixel.classList.add(`hp-class-pixel`);
        pixel.setAttribute(`x`, (x / pixelsX) * sizeX);
        pixel.setAttribute(`y`, (y / pixelsY) * sizeY);
        pixel.setAttribute(`width`, sizeX / pixelsX);
        pixel.setAttribute(`height`, sizeY / pixelsY);

        raster.appendChild(pixel);

        pixels[x][y] = pixel;
    }
}

function rasterize() {
    for (const row of pixels)
    for (const pixel of row) {
        pixel.setAttribute(`style`, ``);
    }

    for (const point of points) {
        const x = point.X;
        const y = point.Y;

        if (x &gt;= 0 &amp;&amp; x &lt; sizeX)
        if (y &gt;= 0 &amp;&amp; y &lt; sizeY) {
            const ix = Math.floor(x / (sizeX / pixelsX));
            const iy = Math.floor(y / (sizeY / pixelsY));

            pixels[ix][iy].setAttribute(`style`, `fill: white`);
        }
    }
    for (const line of lines) {
        const steps = Math.ceil(Math.max(
            Math.abs((line.X1 - line.X2) / (sizeX / pixelsX)),
            Math.abs((line.Y1 - line.Y2) / (sizeY / pixelsY)),
        ));

        for (let i = 0; i &lt;= steps; ++i) {
            const di = i / steps;
            const ix = Math.floor((line.X1 + (line.X2 - line.X1) * di) / (sizeX / pixelsX));
            const iy = Math.floor((line.Y1 + (line.Y2 - line.Y1) * di) / (sizeY / pixelsY));

            if (ix &gt;= 0 &amp;&amp; ix &lt; pixelsX)
            if (iy &gt;= 0 &amp;&amp; iy &lt; pixelsY) {
                pixels[ix][iy].setAttribute(`style`, `fill: white`);
            }
        }
    }
}

rasterize();
        })()
    </script>
</svg>
