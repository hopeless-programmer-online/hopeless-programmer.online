const hosting = require(`../server/hosting`);
const documenting = require(`../server/documenting`);


const h = hosting;
const s = documenting.shortcuts;
const {
    document,
    section,
    paragraph,
    link,
    list,
    sentence,
    // emphasis,
    // figurative,
    // link,
    note,
    illustration,
    code,
    // js,
    // kw,
    v,
    f,
    c,
    // p,
    lt,
    // cm,
} = s;

const cpp = (...x) => code(`c++`, ...x);


const mesa = `https://en.wikipedia.org/wiki/Mesa_(computer_graphics)`;
const glh = cpp(lt(`gl.h`));
const glew = cpp(lt(`glew`));
const glfw = cpp(lt(`glfw`));
const GLuint = cpp(c(`GLuint`));
const glCreateBuffers = cpp(f(`glCreateBuffers`));
const glNamedBufferStorage = cpp(f(`glNamedBufferStorage`));


const code_1 = illustration(`Створення буфера для зберігання вершин.`, cpp(...[
    [ c(`GLuint`), ` `, v(`vertices_buffer_handle`), `;` ],
    [ `` ],
    [ f(`glCreateBuffers`), `(`, lt(`1`), `, &`, v(`vertices_buffer_handle`), `);` ],
]));
const code_2 = illustration(``, cpp(...[
    [ `class Vertex` ],
    [ `{` ],
    [ `    float x;` ],
    [ `    float y;` ],
    [ `};` ],
    [ `` ],
    [ `const std::vector<Vertex> vertices =` ],
    [ `{` ],
    [ `    { -0.5f, -0.5f },` ],
    [ `    { +0.5f, -0.5f },` ],
    [ `    { +0.0f, +0.5f },` ],
    [ `};` ],
]));
const image_1 = illustration(`Растеризація векторних фігур.`,
    new documenting.ImageIllustrationContent({ Url : `/media/cg-2/rasterization.svg` }),
);


exports = module.exports = new h.DocumentResource({
    Document : document(
        [
            sentence(`Програмування комп'ютерної графіки. `),
            sentence(`Графічний конвеєр.`),
        ],
        { Date : new Date(`2020-06-24`) },
        section(`Будова графічного конвеєра.`, ...[
            paragraph(...[
                sentence(`Робота графічного конвеєра зводиться до обробки та виводу на екран графічних об'єктів. `),
                sentence(`За десятки років цей процес розбився на спеціалізовані етапи і набув тої форми, яку він має зараз. `),
                sentence(`Графічні об'єкти розбиваються на окремі графічні примітиви, з якими може працювати GPU. `),
                sentence(`Далі, ці примітиви зберігаються в його оперативній пам'яті разом з іншими даними необхідними для виводу і починається їх обробка. `),
                sentence(`В процесі обробки можуть бути залучені різні етапи конвеєра які перетворюють примітиви, тестують їх і навіть створюють нові. `),
                sentence(`В решті-решт, графічні примітиви перетворюються в набори пікселів на екрані, розраховується їх кінцевий колір і відбувається оновлення екрану. `),
                sentence(`Лише після цього користувач може на власні очі побачити результат роботи конвеєра. `),
            ]),
            paragraph(...[
                sentence(``),
                sentence(``),
                sentence(``),
            ]),
        ]),
        section(`Графічні примітиви.`, ...[
            paragraph(...[
                sentence(`Основними одиницями з якими працює графічний конвеєр є графічні примітиви: точки, лінії та трикунтники`, note(`Взагалі цей список можна розширити квадами, списками трикутників, контурами і іншими специфічними примітивами, але всі вони так чи інакше зводяться до цієї базової трійки. `), `. `),
                sentence(`Вони складаються з вершин: одної, двох та трьох відповідно, а кожна вершина має фіксований набір атрибутів. `),
                sentence(`Загалом, атрибути можна вважати просто числами, які мають для нас певний сенс з точки зору вирішуваної задачі. `),
                sentence(`Наприклад, вершини можуть мати такі атрибути як розташування, колір, температуру, нормаль, прозорість і т.д., які за допомогою чисел описують певні фізичні або вигадані величини. `),
            ]),
            paragraph(...[
                sentence(`Ефективність конвеєра сильно залежить від того, наскільки одноманітною є його робота. `),
                sentence(`Вони влаштовані таким чином, що експлуатують "шаблонність" алгоритмів при обробці вершин. `),
                sentence(`Це означає, що задля найкращого результату кожна вершина чи примітив повинні володіти найменшою кількістю індивідуальних ознак, що впливають на їх обробку`, note([ sentence(`Можна привести аналогію з формами для відтискання. `), sentence(`Якщо на одній формі розмістити багато шаблонів, то за один рух можна буде витиснути багато об'єктів. `), sentence(`Якщо ж багато об'єктів будуть потребувати індивідуального відтискання то потрібна буде додаткова кількість операцій, які, до того ж, доведеться синхронізувати. `) ]), `. `),
                sentence(`Тому, в межах роботи графічного конвеєра - одного виводу - можна виводити лише один тип графічних примітивів. `),
                sentence(`Також, усі вершини цих примітивів повинні мати одинаковий набір атрибутів та одинакову структуру. `),
            ]),
            paragraph(...[
                sentence(`Процес обробки примітивів завершується обчисленням розташування їх вершин в межах області виводу. `),
                sentence(`Можна вважати що ця область є віртуальним екраном з координатною сіткою, на якому ми й розміщуємо вершини. `),
                sentence(`Розташування кожної з них описується четвіркою чисел: x, y, z і w, що лежать в діапазоні [-1, +1]. `),
                sentence(`Координати x та y визначають горизонтальне і вертикальне розташування, де [-1,-1] вважається лівим нижнім кутом області, а [+1,+1] - правим верхнім`, note([ `Напрямок вісі Y може відрізнятись для різних графічних API. `, `Так, наприклад, для DirectX і Vulkan вісь Y скерована зверху-вниз, тоді як для OpenGL вона скерована знизу-вверх. ` ]), `. `),
                sentence(`Координати z і w є менш очевидними і використовуються для роботи з глибиною та для розрахунку перспективи, про що ми поговоримо в інших статтях. `),
                sentence(`Така форма подання графічних примітивів називається векторною і зручна для роботи з ними до виводу. `),
            ]),
        ]),
        section(`Буфер кадру та фрагменти.`, ...[
            paragraph(...[
                sentence(`На іншому кінці графічного конвеєра розташований буфер кадру, заповнений квадратними фрагментами. `),
                sentence(`Кожен такий фрагмент може бути заповнений суцільним кольором, а разом вони формують регулярну прямокутну сітку, яка нагадує мозаїку. `),
                sentence(`Що більше пікселів містить буфер кадру - то чіткішу картинку ми можемо отримати. `),
                // можливо це варто залишити на потім?
                sentence(`Якщо буфер кадру не використовується для відображення на екран, він може складатись з декількох шарів і тоді кожен фрагмент буде одночасно містити декілька різних кольорів. `),
                sentence(`Важливо зауважити, що таке представлення є лише внутрішньою абстракцією з якою працюють в комп'ютерній графіці. `),
                sentence(`Пікселі, з яких складаються реальні монітори, можуть бути не зовсім квадратними, розміщуватись не зовсім регулярно і навряд чи їх колір можна назвати суцільним. `),
            ]),
            paragraph(...[
                sentence(`Колір кожного фрагменту задається набором від одного до чотирьох каналів на шар, зазвичай у діапазоні [0, 1]. `),
                sentence(`Як і у випадку з атрибутами вершин, використання цих каналів може бути довільним, але зазвичай воно визначає реальний фізичний колір. `),
                sentence(`Основною моделлю для роботи з виводом кольору на монітор є RGB або RGBA (Red - червоний, Green - зелений, Blue - синій та Alpha - альфа), у той час як, наприклад, при друці використовується CMY (Cyan - блакитний, Magenta - пурпурний, Yellow - жовтий). `),
            ]),
            // тут моделі RGB та CMY
            paragraph(...[
                sentence(`Модель RGB передбачає, що колір виводиться на чорній поверхні за допомогою додатнього змішування трьох окремих каналів з різною інтенсивністю: червоного, зеленого та синього. `),
                sentence(`Наприклад, якщо інтенсивність червоного каналу рівна одиниці, а решти - нулю, то ми бачимо насичений червоний колір. `),
                sentence(`По мірі того як інтенсивність буде падати - червоний колір буде тьмянішати, доки не стане чорним. `),
                sentence(`Якщо ж червоний і зелений канали будуть мати одиничну інтенсивність, то отриманий колір буде жовтим, а у випадку коли задіяні усі канали - отримаємо білий. `),
                sentence(`Коли усі канали мають однакову інтенсивність меншу за одиницю - ми спостерігаємо відтінки сірого. `),
                sentence(`Так, змінюючи інтенсивність окремих каналів можна отримати будь-який колір з видимого спектру. `),
            ]),
            // тут повинна бути інтерактивний вибирач кольору
            paragraph(...[
                sentence(`Модель RGBA використовує додатковий канал - альфу - для керування прозорістю. `),
                sentence(`Він не використовується при виведенні на екран, але може бути задіяний при змішуванні двох кольорів, один з яких на передньому плані, а другий на задньому. `),
                sentence(`Хоч діапазон значень [0, 1] є дуже зручним при роботі з інтенсивністю кольору, але важливо розуміти що фрагменти буфера кадру можуть використовуватись і для інших цілий. `),
                sentence(`Тому, деколи такі "кольори" можуть виходити далеко за межі одиниці і навіть ставати від'ємними. `),
            ]),
        ]),
        section(`Растеризація.`, ...[
            paragraph(...[
                sentence(`Але, сучасні монітори не розраховані на вивід векторних зображень. `),
                sentence(`Натомість, їх екрани складаються з великої кількості окремих елементів, що можуть випромінювати світло - пікселів. `),
                sentence(`Кожен піксель може набувати певного кольору, а разом вони утворюють мозаїку, яка за достатньої роздільної здатності сприймається нами як. `),
                sentence(``),
            ]),
            paragraph(...[
                sentence(``),
                sentence(``),
                sentence(``),
            ]),
        ]),
        section(``, ...[
            paragraph(...[
                sentence(``),
                sentence(``),
                sentence(``),
            ]),
            paragraph(...[
                sentence(``),
                sentence(``),
                sentence(``),
            ]),
        ]),
    ),
});
