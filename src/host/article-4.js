const hosting = require(`../hosting`);
const documenting = require(`../documenting`);


const h = hosting;
const s = documenting.shortcuts;


const code_1 = require(`./article-4/code-1`);
const code_2 = require(`./article-4/code-2`);
const code_3 = require(`./article-4/code-3`);
const code_4 = require(`./article-4/code-4`);
const code_5 = require(`./article-4/code-5`);
const code_6 = require(`./article-4/code-6`);
const code_7 = require(`./article-4/code-7`);
const code_8 = require(`./article-4/code-8`);
const code_9 = require(`./article-4/code-9`);
const code_10 = require(`./article-4/code-10`);
const code_11 = require(`./article-4/code-11`);
const code_12 = require(`./article-4/code-12`);
const code_13 = require(`./article-4/code-13`);
const code_14 = require(`./article-4/code-14`);
const code_15 = require(`./article-4/code-15`);
const code_16 = require(`./article-4/code-16`);
const code_17 = require(`./article-4/code-17`);

const note_1    = s.note(`Насправді мені просто було ліньки шукати матеріал по темі. `);
const note_2    = s.note(s.sentence(`А це нам точно знадобиться, `, s.link(`Мерфі гарантує`, `https://uk.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%9C%D0%B5%D1%80%D1%84%D1%96`), `!.`));
const note_3    = s.note(...[
    s.sentence(`Принцип підстановки Лісков тут не зовсім доречний, оскільки мова все ж йде `, s.emphasis(`не`), ` про успадкування. `),
    s.sentence(`Даний випадок радше входить до змішаної категорії, в комбінації з іншими принципами SOLID, а саме `, s.link(`принципом розділення інтерфейсу`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%BE%D0%B7%D0%B4%D1%96%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F_%D1%96%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%83`), ` та `, s.link(`принципом інверсії залежностей`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%96%D0%BD%D0%B2%D0%B5%D1%80%D1%81%D1%96%D1%97_%D0%B7%D0%B0%D0%BB%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9`), `. `),
]);
const note_4    = s.note(s.sentence(`Це не повинно створювати для компілятора якихось труднощів, адже мова йде про `, s.emphasis(`не`), ` віртуальну функцію. `));
const note_5    = s.note(`Звичайно, статична типізація не є вадою безпосередньо і в прямому розумінні. `, `Тут мається на увазі те, що разом з іншими особливостями статично типізованих мов реалізувати подібне рішення стає важко. `);

const object_Accept_visitor = s.phrase([ s.v(`object`), `.`, s.f(`Accept`), `(`, s.v(`visitor`), `)` ]);
const visitor_Visit_object = s.phrase([ s.v(`visitor`), `.`, s.f(`Visit`), `(`, s.v(`object`), `)` ]);
const visitor_Visit_number = s.phrase([ s.v(`visitor`), `.`, s.f(`Visit`), `(`, s.v(`number`), `)` ]);
const Visit = s.f(`Visit`);
const Accept = s.f(`Accept`);
const VisitNumber = s.f(`VisitNumber`);
const VisitString = s.f(`VisitString`);
const number_Accept_visitor = s.phrase([ s.v(`number`), `.`, s.f(`Accept`), `(`, s.v(`visitor`), `)` ]);
const visitor_VisitNumber_number = s.phrase([ s.v(`visitor`), `.`, s.f(`VisitNumber`), `(`, s.v(`number`), `)` ]);
const number = s.v(`number`);
const visitor = s.v(`visitor`);
const others = s.phrase([ `...`, s.v(`others`) ]);
const $Object = s.c(`Object`);
const Object_Accept = s.phrase([ s.c(`Object`), `.`, s.f(`Accept`) ]);

exports = module.exports = new h.DocumentResource({
    Document : s.document([ `Це можна покращити! `, `Відвідувач та ECMAScript 6. ` ],
        {
            Date : new Date(`2019-03-03T00:00:00.000Z`),
        },
        s.section(`Передмова`, ...[
            s.paragraph(...[
                s.sentence(s.link(`Відвідувач`, `https://uk.wikipedia.org/wiki/%D0%92%D1%96%D0%B4%D0%B2%D1%96%D0%B4%D1%83%D0%B2%D0%B0%D1%87_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)`), ` (`, /*translation(), ` `, term(`visitor`),*/ `) - один з класичних `, s.link(`шаблонів проектування`, `https://uk.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B8_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B7%D0%B0%D0%B1%D0%B5%D0%B7%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%BD%D1%8F`), `. `),
                s.sentence(`Про нього часто розказують як у навчальних закладах, так і на різноманітних курсах з програмування. `),
                s.sentence(`Він не зав'язаний на особливості якоїсь конкретної мови, а тому (в теорії) застосувати його можна будь де. `),
            ]),
            s.paragraph(...[
                s.sentence(`Нещодавно мені випала нагода використати відвідувач в `, s.link(`ECMAScript 6`, `https://uk.wikipedia.org/wiki/ECMAScript`), ` на робочому проекті. `),
                s.sentence(`До цього я стикався з ним лише в мовах зі `, s.link(`статичною типізацією`, `https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%82%D0%B8%D0%BF%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%97`), `, а тому моя перша реалізація не була позбавлена вад властивих цьому класу мов. `),
                s.sentence(`Але час проведений наодинці з `, s.link(`JavaScript`, `https://uk.wikipedia.org/wiki/JavaScript`), ` не минув без наслідків. `),
                s.sentence(`Динамічна типізація все ж зробила свою брудну справу і коли я отямився було вже надто пізно... `),
                s.sentence(`Відвідувача тепер не впізнала б і рідна мати! Він вже не був тою `, s.figurative(`класичною реалізацією`), `, яку ми всі знали. На щастя. `),
            ]),
            s.paragraph(...[
                s.sentence(`Я вирішив пошукати схожі реалізації цього шаблону на ES6, але не знайшов чогось суттєво просунутішого за класичний варіант. `),
                s.sentence(`А це при тому, що мова є динамічно-типізованою, тобто дозволяє повертати і передавати в якості аргументів довільні об'єкти! `),
                s.sentence(`Ай-яй-яй... що ж, доведеться мені самому взятись за це`, note_1, `! `),
            ]),
        ]),
        s.section(`Область застосування`, ...[
            s.paragraph(...[
                s.sentence(`Для початку варто було б згадати навіщо взагалі потрібен відвідувач. `),
                s.sentence(`Припустимо що у нас є деяка ієрархія класів. `),
                s.sentence(`Наприклад, примітиви типу чисел, стрічок, масивів і т.д. (див. `, code_1, `). `),
                s.sentence(`Наповнення цих класів не є важливим, а тому ми залишимо його за кулісами. `),
                s.sentence(`Завдання - реалізувати програму яка б перетворювала екземпляри цих класів в, наприклад, `, s.link(`JSON`, `https://uk.wikipedia.org/wiki/JSON`), `. `),
            ]),
            s.paragraph(...[
                s.sentence(`Ми не випадково обрали саме такі класи і саме такий формат даних. `),
                s.sentence(`Усі вони - логічні типи, числа, стрічки, масиви - вже реалізовані в JavaScript. `),
                s.sentence(`Те саме можна сказати і про механізм їхнього перетворення в JSON. `),
                s.sentence(`У цьому є перевага, адже працювати з добре відомими явищами легше. `),
                s.sentence(`Окрім цього методи вирішення цієї задачі можна порівняти з уже існуючими підходами. `),
                s.sentence(`Це дуже добре показує те, що вирішувана задача не синтетична а цілком реальна. `),
            ]),
            s.paragraph(...[
                s.sentence(`То що б ми зробили будучи на місці розробників JavaScript? `),
                s.sentence(`Одним із найпростіших рішень є додавання в кожен клас спеціального методу. `),
                s.sentence(`Цей метод відповідає за перетворення відповідного об'єкта і викликається безпосередньо (див. `, code_2, `). `),
                s.sentence(`На перший погляд така ідея є абсолютно здоровою, адже вона вирішує поставлену задачу. `),
                s.sentence(`Але це лише на перший погляд... `),
            ]),
            [
                code_1,
                code_2,
            ],
            s.paragraph(...[
                s.sentence(`Тепер звернемось до свого внутрішнього критика і спробуємо знайти вади в подібному дизайні. `),
                s.sentence(`Перше що можна помітити - це `, s.link(`нагромадження обов'язків`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%94%D0%B4%D0%B8%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%BE%D0%B2%27%D1%8F%D0%B7%D0%BA%D1%83`), `. `),
                s.sentence(`Кожен з наших класів тепер не лише реалізує конкретний тип даних, а ще й вміє перетворювати його в JSON. `),
                s.sentence(`Це проблема, оскільки предметні області `, /*term*/(`бути числом/стрічкою/масивом`), ` і `, /*term*/(`вміти перетворюватись в JSON`), ` стають зв'язаними. `),
                s.sentence(`Ми вже не зможемо використовувати їх окремо`, note_2, `. `),
                s.sentence(`Вони стають залежними одна від одної, хоча це `, s.emphasis(`не`), ` є необхідним. `),
            ]),
            s.paragraph(...[
                s.sentence(`Далі, якщо нам знадобиться підтримка ще одного формату, наприклад, `, s.link(`XML`, `https://uk.wikipedia.org/wiki/XML`), `, то доведеться додавати в `, s.emphasis(`існуючі`), ` класи нові методи (див. `, code_3, `). `),
                s.sentence(`Така залежність змушує нас `, s.link(`модифікувати вже написані класи`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B2%D1%96%D0%B4%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96/%D0%B7%D0%B0%D0%BA%D1%80%D0%B8%D1%82%D0%BE%D1%81%D1%82%D1%96`), `, замість того щоб розширювати їх. `),
            ]),
            [
                code_3,
                code_4,
            ],
            s.paragraph(...[
                s.sentence(`Зрештою, перетворення в JSON та XML виглядають дуже схожими операціями. `),
                s.sentence(`І було б природно мати можливість `, s.emphasis(`динамічно`), ` `, s.link(`замінювати одну операцію іншою`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BF%D1%96%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8_%D0%9B%D1%96%D1%81%D0%BA%D0%BE%D0%B2`), note_3, `. `),
                s.sentence(`Але вибрана нами стратегія не дає нам змоги зробити це. `),
                s.sentence(`Для цього необхідно замінити метод. `),
                s.sentence(`А зробити це `, s.emphasis(`динамічно`), ` в статично-типізованих мовах програмування неможливо. `),
                s.sentence(`На щастя тут ми можемо використати особливість JavaScript і викликати метод за іменем (див. `, code_4, `). `),
                s.sentence(`В даному випадку це спрацює, хоч такий пошук і не є швидкою операцією. `),
            ]),
        ]),
        s.section(`Ідея`, ...[
            s.paragraph(...[
                s.sentence(`Для усунення цих вад і використовують відвідувача. `),
                s.sentence(`Ідея полягає у тому, що потрібно відділити дані від алгоритмів їх опрацювання. `),
                s.sentence(`Кінцевим результатом мав би стати дизайн, де методи ToJSON та ToXML перетворюються в окремі класи JSON та XML (див. `, code_5, `). `),
            ]),
            code_5,
            s.paragraph(...[
                s.sentence(`Але і тут не все так просто. Це завдання теж можна вирішити не єдиним способом, причому з різною ефективністю. `),
                s.sentence(`Є три досить поширені та однаково неефективні ідеї (див. `, code_6, `, `, code_7, ` та `, code_8, `): `),
            ]),
            s.list(...[
                s.sentence(`Ввести допоміжне поле для визначення типу об'єкта і в залежності від нього проводити галуження. `),
                s.sentence(`Проводити галуження виходячи з конструктора об'єкта. `),
                s.sentence(`Намагатись приводити об'єкти до відповідних типів вручну. `),
            ]),
            s.paragraph(...[
                s.sentence(`Ці підходи теж вирішують завдання, але кожен з них має свої вади. `),
                s.sentence(`По-перше, якщо проводити галуження виходячи з конструктора об'єкта (див. `, code_6, `), то ми втрачаємо сумісність з усіма похідними класами. `),
                s.sentence(`По-друге, введення додаткового поля для визначення типу (див. `, code_7, `) є надлишковим, оскільки інформація про тип може бути виведена з деякого аналогу `, /*term*/(`таблиці віртуальних методів`), `. `),
                s.sentence(`По-третє і галуження, і приведення до типу не є дешевими операціями. `),
                s.sentence(`В даному випадку є можливість обійтись без їхнього використання. `),
            ]),
            [
                code_6,
                code_7,
                code_8,
            ],
        ]),
        s.section(`Реалізація`, ...[
            s.paragraph(...[
                s.sentence(`Класична реалізація відвідувача позбавлена згаданих вище вад. `),
                s.sentence(`Перший крок - це створення деякої проміжної ланки, яка б надавала можливість звернення до об'єктів відповідно до їхнього `, s.link(`типу`, `https://uk.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85`), ` (див. `, code_9, `). `),
                s.sentence(`Наступний крок - це передача процесу `, s.link(`диспетчеризації`, `https://uk.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D1%82%D0%BE%D0%B4`), ` в область відповідальності самого об'єкта. `),
                s.sentence(`Тобто, тепер саме `, /*term*/(`число`), ` приймає рішення що з ним потрібно працювати як з числом (див. `, code_10, `). `),
            ]),
            [
                code_9,
                code_10,
            ],
            s.paragraph(...[
                s.sentence(`Останній крок - це використання `, s.link(`поліморфізму`, `https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%96%D0%BC%D0%BE%D1%80%D1%84%D1%96%D0%B7%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)`), ` в класах з попередніх кроків. `),
                s.sentence(`Введення `, s.link(`абстрактного методу`, `https://uk.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4`), ` в `, /*term*/(`об'єкт`), ` дозволить опрацьовувати як `, /*term*/(`число`), ` так і `, /*term*/(`стрічку`), ` `, s.emphasis(`без`), ` визначення їхнього типу. `),
                s.sentence(`Далі, реалізація методів `, /*term*/(`відвідувача`), ` як абстрактних дозволить `, s.link(`замістити`, `https://uk.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%96%D1%89%D0%B5%D0%BD%D0%BD%D1%8F_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%83`), ` їх. `),
                s.sentence(`Таким чином похідні класи зможуть визначати алгоритми опрацювання для `, s.emphasis(`конкретних`), ` типів, уникаючи приведення. `),
            ]),
            s.paragraph(...[
                s.sentence(`Класи JSON та XML лише `, s.link(`успадковують`, `https://uk.wikipedia.org/wiki/%D0%A3%D1%81%D0%BF%D0%B0%D0%B4%D0%BA%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)`), ` Visitor і реалізовують методи для опрацювання відповідних класів (див. `, code_11, `). `),
                s.sentence(/*term*/(`Перенаправлення`), ` викликів відповідно до типу відбувається неявно, зусиллями самих опрацьовуваних об'єктів. `),
                s.sentence(`Усе це відбувається задешево - ціною виклику лише одного `, s.link(`віртуального методу`, `https://uk.wikipedia.org/wiki/%D0%92%D1%96%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4`), `. `),
                s.sentence(`Це дешевше ніж галуження чи приведення до типу. `),
                s.sentence(`Можливо, виходячи з постановки задачі, це `, s.emphasis(`в принципі`), ` найдешевший варіант з точки зору швидкодії. `),
            ]),
            code_11,
            s.paragraph(...[
                s.sentence(`Ось це була `, s.figurative(`класична`), ` реалізація відвідувача. `),
                s.sentence(`Та, яка часто використовується в статично-типізованих мовах типу `, s.link(`C#`, `https://uk.wikipedia.org/wiki/C_Sharp`), `, `, s.link(`Java`, `https://uk.wikipedia.org/wiki/Java`), ` чи `, s.link(`C++`, `https://uk.wikipedia.org/wiki/C%2B%2B`), `. `),
                s.sentence(`Але `, s.link(`JavaScript`, `https://uk.wikipedia.org/wiki/JavaScript`), `, а тим паче `, s.link(`ECMAScript 6`, `https://uk.wikipedia.org/wiki/ECMAScript`), `, має певні особливості які дозволяють робити речі, неможливі з точки зору вищезгаданих мов. `),
            ]),
        ]),
        s.section(`Розвиваємо ідею`, ...[
            s.paragraph(...[
                s.sentence(`Перше, що можна покращити - це зовнішній вигляд. `),
                s.sentence(`Можна перенести виклик `, object_Accept_visitor, ` всередину нового методу: `, visitor_Visit_object, ` (див. `, code_12, `). `),
                s.sentence(`З точки зору продуктивності ми радше за все нічого не втратимо, такий виклик легко може бути оптимізований`, note_4, `. `),
                s.sentence(`З точки ж зору синтаксису метод `, Visit, ` візуально легше зіставити з методами `, VisitNumber, `, `, VisitString, ` і т.д.. `),
                s.sentence(`Створюється ілюзія того, що поліморфізм діє через аргументи і автоматично вибирає ту реалізацію, яка збігається з типом відвідуваного об'єкту. `),
            ]),
            code_12,
            s.paragraph(...[
                s.sentence(`Іншими словами - зв'язок між `, number_Accept_visitor, ` та `, visitor_VisitNumber_number, ` не є очевидний. `),
                s.sentence(`Дуже важко здогадатись, що перший метод об'єкта `, number, ` призведе до виклику іншого методу об'єкта `, visitor, `. `),
                s.sentence(`А от у випадку `, visitor_Visit_number, ` та `, visitor_VisitNumber_number, ` все простіше. `),
                s.sentence(`Методи не лише мають схожі назви, але й стосуються одного і того ж об'єкта. `),
                s.sentence(`У цьому випадку користувачу легше дистанціюватись від особливостей реалізації, віддавши все на волю `, s.figurative(`магії`), `. `),
            ]),
            s.paragraph(...[
                s.sentence(`Далі, ми можемо використати динамічну типізацію JavaScript і дозволити методам `, Visit, `, `, Accept, ` та `, VisitNumber, ` повертати результат. `),
                s.sentence(`В статично типізованих мовах цього важко досягнути, оскільки тип результату має бути відомий заздалегідь. `),
                s.sentence(`Доводиться йти на компроміси. `),
                s.sentence(`Можна відмовитись від результату, акумулюючи його всередині об'єкта. `),
                s.sentence(`Але це робить неможливим використання функціонального програмування, та й узагалі погано впливає на зручність механізму в цілому. `),
                s.sentence(`Можна повертати абстрактний результат, який потім можна буде привести до потрібного типу. `),
                s.sentence(`Це створює зайву операцію приведення, але допомагає обійти дану проблему. `),
                s.sentence(`На щастя JavaScript позбавлений цих `, s.figurative(`вад`), note_5, `, а тому ми можемо дозволити собі подібну розкіш (див. `, code_13, `). `),
            ]),
            code_13,
            s.paragraph(...[
                s.sentence(`Також часто виникає питання про додаткові аргументи при відвідуванні об'єктів. `),
                s.sentence(`І знову перешкодою для цього може стати статична типізація, відсутня в JavaScript. `),
                s.sentence(`В інших мовах часто доводиться передавати такі аргументи через `, s.link(`поля`, `https://uk.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B5_%D0%BA%D0%BB%D0%B0%D1%81%D1%83`), ` самого відвідувача, але в нашому випадку це не потрібно. `),
                s.sentence(`Окрім цього, використовуючи ECMAScript 6 можна не лише зробити додаткові аргументи можливими, але й зручними та інтуїтивно зрозумілими. `),
                s.sentence(`Використовуючи оператори для `, s.link(`решти аргументів`, `https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Functions/%D1%80%D0%B5%D1%88%D1%82%D0%B0_%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%96%D0%B2`), ` та `, s.link(`розпакування`, `https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80_%D1%80%D0%BE%D0%B7%D0%BF%D0%B0%D0%BA%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F`), ` можна вирішити все розмноживши єдиний рядок - `, others, ` (див. `, code_14, `). `),
                s.sentence(`Це не лише `, s.emphasis(`не`), ` буде конфліктувати з базовим класом і рештою інфраструктури, але й дозволить реалізувати різну кількість і типи аргументів для різних відвідуваних об'єктів. `),
            ]),
            code_14,
        ]),
        s.section(`Ще не все!`, ...[
            s.paragraph(...[
                s.sentence(`Можна не зупинятись на досягнутому. `),
                s.sentence(`Ще одна область для вдосконалення - це особлива диспетчеризація тих класів, які успадковують `, $Object, `, але `, s.emphasis(`не`), ` реалізують метод `, Accept, `. `),
                s.sentence(`Для цього можна ввести у відвідувач додатковий метод, який буде опрацьовувати ці об'єкти. `),
                s.sentence(`Також метод `, Object_Accept, ` тепер буде мати початкову реалізацію, а похідні класи зможуть змінювати її за бажанням (див. `, code_15, `). `),
            ]),
            code_15,
            s.paragraph(...[
                s.sentence(`Ще один розповсюджений недолік класичної реалізації відвідувача - це необхідність визначати всі його методи, навіть якщо більша їх половина має ідентичний код. `),
                s.sentence(`Припустимо, що ми хочемо перетворювати в JSON `, s.emphasis(`лише`), ` числа. `),
                s.sentence(`Усі ж інші об'єкти ми будемо повертати у вигляді порожньої стрічки. `),
                s.sentence(`В такій ситуації нам доведеться визначити стільки методів, скільки класів існує в нашій ієрархії (див. `, code_16, `). `),
                s.sentence(`Окрім цього, така реалізація буде не стабільною, оскільки додавання нових класів буде змушувати нас додавати нові `, s.emphasis(`однотипні`), ` методи до похідного відвідувача. `),
            ]),
            [
                code_16,
                code_17,
            ],
            s.paragraph(...[
                s.sentence(`Але є спосіб боротись з цим. `),
                s.sentence(`Можна оголосити ще один опрацьовувач в базовому класі відвідувача. `),
                s.sentence(`Він буде працювати `, s.emphasis(`лише`), ` з тими об'єктами, обробка яких `, s.emphasis(`не`), ` є заміщеною в похідному класі. `),
                s.sentence(`Досягається це за допомогою перенаправлення з усіх методів `, Visit, ` базового класу (див. `, code_17, `). `),
                s.sentence(`Заміщені ж методи не будуть наділені такою поведінкою, реалізуючи натомість код для опрацювання об'єкта конкретного типу. `),
                s.sentence(`Такий підхід не лише зменшить кількість коду, але й позбавить нас необхідності в додаванні нових методів. `),
            ]),
        ]),
        s.section(`Післямова`, ...[
            s.paragraph(...[
                s.sentence(`Відвідувач - доволі корисний шаблон проектування. `),
                s.sentence(`Він допомагає не лише правильно відділити та інкапсулювати логіку обробки даних, але й зробити цей процес ефективним з точки зору швидкодії. `),
                s.sentence(`Багато талановитих розробників яким пощастило не знати про існування відвідувача самі винаходять його в своїй практиці, хоч і називають по іншому. `),
            ]),
            s.paragraph(...[
                s.sentence(`Не зважаючи на свою потужність цей підхід все ж має недоліки. `),
                s.sentence(`Але деякі з них можна обійти в залежності від вибраної мови програмування. `),
                s.sentence(`Навряд чи я зміг привести тут усі можливі розвинення відвідувача для ECMAScript 6. `),
                s.sentence(`Але я сподіваюсь що описані тут ідеї все ж знадобляться комусь в його роботі. `),
            ]),
        ]),
    ),
});
