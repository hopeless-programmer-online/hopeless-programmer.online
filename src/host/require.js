const hosting = require(`../hosting`);
const documenting = require(`../documenting`);


const h = hosting;
const s = documenting.shortcuts;


const require_ = s.phrase(s.f(`require`));
const module_ = s.phrase(s.c(`module`));
const exports_ = [ module_, s.lexeme(`.`), s.v(`exports`) ];


const code_1 = s.illustration( ...[
    s.sentence(`Отримання переліку вбудованих модулів. `),
    s.code(
        [ s.cm(`// список усіх модулів ядра`) ],
        [ s.f(`require`), `(`, s.lt(`\`module\``), `).`, s.p(`builtinModules`), `;` ],
        [ s.cm(`/**`) ],
        [ s.cm(` * [`) ],
        [ s.cm(` *     "path",`) ],
        [ s.cm(` *     "http",`) ],
        [ s.cm(` *     "fs",`) ],
        [ s.cm(` *     ...`) ],
        [ s.cm(` * ]`) ],
        [ s.cm(` */`) ],
    ),
]);


exports = module.exports = new h.DocumentResource({
    Document : s.document(s.sentence(`Все що я знаю про: `, s.f(`require`), `. `),
        s.section(`Загальні принципи. `, ...[
            s.paragraph(...[
                s.sentence(`Перед тим як говорити про нюанси роботи `, require_, ` є сенс описати загальні принципи його роботи. `),
                s.sentence(`Весь процес можна умовно розбити на 3 етапи: пошук модуля, його виконання та кешування. `),
                s.sentence(`В процесі пошуку `, require_, ` визначається з джерелом коду потрібного модуля. `),
                s.sentence(`Далі, цей код буде виконаний в ізольованій області, зі своїми власними змінними `, require_, ` та `, module_, `. `),
                s.sentence(`Після того як код виконано а `, ...exports_, ` заповнений відповідними значеннями, ця змінна зберігається в кеші. `),
                s.sentence(`При подальших звернення до цього ж модуля він вже не буде виконуватись. `),
                s.sentence(`Натомість, буде повернене значення збережене в кеші. `),
                s.sentence(``),
            ]),
            s.paragraph(...[
                s.sentence(`Одразу варто зазначити що це лише загальна картина того що відбувається і вагомий внесок несуть саме деталі. `),
            ]),
        ]),
        s.section(`Пошук`, ...[
            s.paragraph(...[
                s.sentence(`Одразу після початку пошуку `, require_, ` перевіряє чи переданий ідентифікатор збігається з назвою якогось з модулів ядра. `),
                s.sentence(`Це модулі типу `, s.lt(`path`), ` або `, s.lt(`fs`), `, вбудовані в NodeJS, а їх повний перелік можна отримати за допомогою властивості `, s.p(`builtinModules`), ` модуля `, s.lt(`fs`), code_1, `. `),
                s.sentence(`Якщо потрібний модуль знайдений в ядрі - він одразу ж і повертається. `),
                s.sentence(`Якщо ж ні - пошук продовжується далі. `),
                s.sentence(`Вже на цьому етапі можна зробити важливий висновок: не варто називати власний модуль іменем, зарезервованим за модулем ядра. `),
            ]),
            [
                code_1,
            ],
            s.paragraph(...[
                s.sentence(`Якщо передана в `, require_, ` стрічка починається з послідовності символів `, s.lt(`/`), `, `, s.lt(`./`), ` або `, s.lt(`../`), ` - алгоритм буде трактувати це як шлях відносно файлу з якого відбувався виклик функції. `),
                s.sentence(`Спочатку за вказаним шляхом буде шукатись файл без розширення, потім файл з розширенням `, s.lt(`.js`), `, потім `, s.lt(`.json`), `, потім `, s.lt(`.node`), `. `),
                s.sentence(`Важливо те, що `, s.lt(`.json`), ` файл буде перетворений у відповідний йому об'єкт, а файл без розширення буде інтерпретуватись як файл з розширенням `, s.lt(`.js`), `. `),
                s.sentence(`Тут теж можна зробити два маленьких висновки: 1. `, require_, ` - це найпростіший спосіб завантажити `, s.lt(`json`), ` об'єкт. 2. Файл без розширення буде завантажуватись в першу чергу і якщо про це не знати то є ризик натрапити на неочікувану поведінку. `),
            ]),
            s.paragraph(...[
                s.sentence(`Якщо за вказаним шляхом не існує файлу, але існує каталог - події будуть розвиватись по-іншому. `),
                s.sentence(`В першу чергу алгоритм буде шукати у вказаному каталозі файл `, s.lt(`package.json`), `. `),
                s.sentence(`Якщо такого файлу не існує, то аглоритм намагатиметься послідовно завантажити з каталогу файли `, s.lt(`index.js`), `, `, s.lt(`index.json`), ` та `, s.lt(`index.node`), ` за аналогією з завантаженням файлу. `),
                s.sentence(`І ще два важливі висновоки: 1. У цьому конкретному випадку файл без розширення не буде завантажуватись. 2. Файл `, s.lt(`package.json`), ` грає роль навіть при завантаженні з використанням відносного шляху. `),
            ]),
            s.paragraph(...[
                s.sentence(`За умови що `, s.lt(`package.json`), ` існує, алгоритм завантажить його та буде шукати в ньому поле `, s.p(`main`), `. `),
                s.sentence(`Значення цього поля буде трактуватись як відносний шлях до файлу з кодом модуля. `),
                s.sentence(`Якщо ж такого поля або файлу немає - алгоритм буде намагатись завантажити файли `, s.lt(`index.*`), `. `),
                s.sentence(`Також важливо підкреслити, що поле `, s.p(`main`), ` трактується саме як шлях до файлу і з його допомогою вже не вийде посилатись на інший `, s.lt(`package.json`), `. `),
            ]),
            s.paragraph(...[
                s.sentence(``),
                s.sentence(``),
            ]),
            s.paragraph(...[
                s.sentence(``),
                s.sentence(``),
            ]),
        ]),
    ),
});
