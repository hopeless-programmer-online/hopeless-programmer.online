const hosting = require(`../server/hosting`);
const documenting = require(`../server/documenting`);


const h = hosting;
const s = documenting.shortcuts;
const {
    document,
    section,
    paragraph,
    sentence,
    figurative,
    emphasis,
    link,
    lexeme,
    code,
    js,
    cs,
} = s;


const code_1 = require(`./keywords/code-1`);
const code_2 = require(`./keywords/code-2`);
const code_3 = require(`./keywords/code-3`);
const code_4 = require(`./keywords/code-4`);
const code_5 = require(`./keywords/code-5`);
const code_6 = require(`./keywords/code-6`);
const code_7 = require(`./keywords/code-7`);
const code_8 = require(`./keywords/code-8`);
const code_9 = require(`./keywords/code-9`);
const code_10 = require(`./keywords/code-10`);
const code_11 = require(`./keywords/code-11`);
const code_12 = require(`./keywords/code-12`);
const code_13 = require(`./keywords/code-13`);


exports = module.exports = new h.DocumentResource({
    Document : document([ `Думки вголос. `, `Зарезервовані слова. ` ],
        {
            Date : new Date(`2019-02-24T00:00:00.000Z`),
        },
        section(``, ...[
            paragraph(...[
                sentence(`Дуже часто мови програмування грішать тим, що змішують в одну купу ідентифікатори та ключові слова. `),
                sentence(`Разом з іншими недоліками це породжує цілу низку дрібних проблем. `),
                sentence(`Деколи вони можуть стати справжньою ложкою дьогтю як для мови в цілому, так і для окремої програми. `),
                sentence(`Такий стан справ мене не влаштовує. `),
                sentence(`А тому я вирішив привести приклади підходів котрі позбавлені подібних вад, а також мов що їх реалізують. `),
            ]),
        ]),
        section(`Претензії`, ...[
            paragraph(...[
                sentence(`З точки зору синтаксису зарезервовані слова є `, emphasis(`особливими`), ` ідентифікаторами. `),
                sentence(`Зазвичай вони залучені в службових конструкціях мови: галуженнях, циклах, оголошеннях і т.д. `, code_1, `. `),
                sentence(`Використовувати їх для іменування об'єктів `, emphasis(`заборонено`), `. `),
                sentence(`Хоч і в незначній мірі це все ж обмежує вільний до використання словниковий запас. `),
                sentence(`Також від цього може страждати і подальший розвиток мови. `),
                sentence(`Введення нових зарезервованих слів може погіршувати зворотню сумісність через можливі конфлікти з існуючими ідентифікаторами. `),
                sentence(`Інколи це змушує вводити в мову дещо `, figurative(`кострубаті`), ` і неприродні конструкції `, code_2, `. `),
                sentence(`Вони рятують ситуацію в цілому, але не додають коду елегантності чи однорідності. `),
            ]),
            [
                code_1,
                code_2,
            ],
            paragraph(...[
                sentence(`Наскільки цей підхід виправданий? `),
                sentence(`Наскільки він потрібний в сучасних мовах програмування? `),
                sentence(`Чи можна взагалі хоч якось покращити ситуацію? `),
            ]),
        ]),
        section(sentence(emphasis(`Не`), ` вирішення проблеми`), ...[
            paragraph(...[
                sentence(`Цікавий, хоч і безрезультатний хід зробили автори `, link(`мови C#`, `https://uk.wikipedia.org/wiki/C_Sharp`), `. `),
                sentence(`Вони дозволили використовувати зарезервовані слова в якості ідентифікаторів, але з однією умовою - ідентифікатор повинен починатись з символу `, cs(lexeme(`@`)), `. `),
                sentence(`Мені невідомо на який результат чекали розробники, але проблема нікуди не зникла. `),
                sentence(`Ми як і раніше не можемо використовувати зарезервовані слова в якості ідентифікаторів. `),
                sentence(`Саме ж запропоноване рішення принципово не відрізняється від використання інших префіксів `, code_3, `. `),
            ]),
            [
                code_3,
                code_4,
            ],
            paragraph(...[
                sentence(`Окрім цього такий підхід не позбавлений недоліків. `),
                sentence(`Наприклад, символ `, lexeme(`@`), ` заборонено використовувати в якості самостійної змінної. `),
                sentence(`З його допомогою можна оголосити і звичайні ідентифікатори, але неможливо розмістити всередині чи позаду них `, code_4, `. `),
                sentence(`Також він застосовується при оголошенні стрічкових літералів, а це може ускладнювати розуміння призначення такої конструкції. `),
            ]),
            paragraph(...[
                sentence(`Мета яку переслідували автори цього рішення для мене залишається не очевидною. `),
                sentence(`Але спроба боротись з проблемою зарезервованих слів зарахована. `),
            ]),
        ]),
        section(`Виділення ідентифікаторів`, ...[
            paragraph(...[
                sentence(`В `, link(`мові PHP`, `https://uk.wikipedia.org/wiki/PHP`), ` до цього питання підійшли з іншого боку. `),
                sentence(`Змінні в ній виділені в окрему синтаксичну категорію і починаються з символу `, code(`php`, lexeme(`$`)), ` `, code_5, `. `),
                sentence(`Це відрізняє їх від функцій і службових слів, які не можуть починатись з `, code(`php`, lexeme(`$`)), `. `),
                sentence(`Як і в попередньому випадку тут заборонені `, figurative(`порожні`), ` змінні та символ `, code(`php`, lexeme(`$`)), ` всередині ідентифікатора, але в цілому підхід є більш повним. `),
                sentence(`Змінні і службові слова чітко розділені і не перетинаються, користувачі вільні у виборі імен а розробники мови в розширенні службових конструкцій. `),
                sentence(`Єдиний недолік - це користувацькі функції, які й далі можуть конфліктувати з зарезервованими словами.`),
            ]),
            paragraph(...[
                sentence(`Автори `, link(`проміжної мови LLVM`, `https://uk.wikipedia.org/wiki/Low_Level_Virtual_Machine`), ` застосували блискуче з цієї точки зору рішення. `),
                sentence(`Саме з метою усунення можливих проблем зворотної сумісності, а також конфліктів між ідентифікаторами та службовими словами, `, link(`ідентифікатори в LLVM`, `https://releases.llvm.org/2.6/docs/LangRef.html#identifiers`), ` починаються зі спеціального префіксу. `),
                sentence(`Глобальні ідентифікатори (функції, глобальні змінні) починаються з символу `, code(`llvm`, lexeme(`@`)), `, у той час як локальні (регістри, типи) - з символу `, lexeme(`%`), `. `),
                sentence(`Службові слова ж позбавлені цих префіксів, а тому конфлікти між ними неможливі`, code_6, `. `),
            ]),
            paragraph(...[
                sentence(`В `, link(`мові BASIC`, `https://uk.wikipedia.org/wiki/BASIC`), ` та її діалектах розвинутий схожий підхід, хоч і використаний з іншою метою. `),
                sentence(`Ідентифікатори змінних можна записувати зі спеціальним суфіксом, який буде явно визначати їхній тип `, code_7, `. `),
                sentence(`Важливо те, що це дозволяє оголошувати змінні ідентичні до службових слів не призводячи до конфліктів `, code_8, `. `),
            ]),
            [
                code_5,
                code_6,
                code_7,
                code_8,
            ],
            paragraph(...[
                sentence(`Ідею з виділенням змінних можна поширити і на решту ідентифікаторів: функції, класи, простори імен, тощо. `),
                sentence(`Відкритим залишається питання зі стандартною бібліотекою, адже в залежності від мови вона може використовуватись по різному. `),
                sentence(`Незалежно від цього такий підхід усуває проблеми зворотної сумісності при додаванні нових конструкцій в мову. `),
                sentence(`Додавання в мову класів чи шаблонів, атрибутів чи класифікаторів, або навіть звичайних циклів гарантовано не буде створювати конфліктів з існуючими ідентифікаторами. `),
            ]),
        ]),
        section(`Виділення ключових слів`, ...[
            paragraph(...[
                sentence(`Існує і діаметрально протилежний підхід. `),
                sentence(`Замість того щоб `, figurative(`виділяти`), ` ідентифікатори можна виділити службові слова. `),
                sentence(`Вибір на їхню користь може бути обґрунтований тим, що частота вживання ключових слів зазвичай нижча за частоту вживання звичайних ідентифікаторів. `),
                sentence(`Виходячи з такої позиції користувачам може бути простіше додавати спеціальний префікс до ключового слова, а не до часто використовуваних змінних та класів. `),
            ]),
            paragraph(...[
                sentence(`Така стратегія використана в `, link(`мові С`, `https://uk.wikipedia.org/wiki/C_(%D0%BC%D0%BE%D0%B2%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F)`), `, де команди `, link(`препроцесора`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D0%BE%D1%80`), ` починаються з символу решітки (`, code(`c`, lexeme(`#`)), `). `),
                sentence(`Це виділяє їх на фоні ідентифікаторів та решти службових слів, перетворюючи на окрему `, link(`предметно-орієнтовану мову`, `https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D1%96%D1%94%D0%BD%D1%82%D0%BE%D0%B2%D0%B0%D0%BD%D0%B0_%D0%BC%D0%BE%D0%B2%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F`), ` всередині іншої мови `, code_9, `. `),
                sentence(`Ще одним прикладом префіксу для виділення службових слів є обернена коса риска (`, js(lexeme(`\\`)), `). `),
                sentence(`Вона використовується в `, link(`мові регулярних виразів`, `https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D0%B8%D0%B9_%D0%B2%D0%B8%D1%80%D0%B0%D0%B7`), ` а також в `, link(`мові розмітки LaTeX`, `https://uk.wikipedia.org/wiki/LaTeX`), `. `),
            ]),
            paragraph(...[
                sentence(`Також поширеним є варіант з записом службових слів між парою дужок або інших символів. `),
                sentence(`Так, наприклад, мови розмітки `, link(`XML`, `https://uk.wikipedia.org/wiki/XML`), ` та `, link(`HTML`, `https://uk.wikipedia.org/wiki/XML`), ` використовують кутові дужки (`, code(`html`, lexeme(`<`)), ` та `, code(`html`, lexeme(`>`)), `) для запису теґів `, code_10, `. `),
                sentence(`Іншим прикладом можуть слугувати атрибути в сучасних мовах програмування (`, link(`Java`, `https://uk.wikipedia.org/wiki/Java`), `, `, link(`C#`, `https://uk.wikipedia.org/wiki/C_Sharp`), `, `, link(`C++`, `https://uk.wikipedia.org/wiki/C%2B%2B`), `). `),
                sentence(`Нерідко їх розміщують всередині одинарних або подвійних квадратних дужок (`, cs(lexeme(`[`)), ` та `, cs(lexeme(`]`)), `). `),
            ]),
            [
                code_9,
                code_10,
            ],
        ]),
        section(`Змішаний підхід`, ...[
            paragraph(...[
                sentence(`Ще одна стратегія - це робота зі службовими словами як зі звичайними ідентифікаторами. `),
                sentence(`Тут мається на увазі те, що службові слова перестають бути контекстно-незалежними лексемами. `),
                sentence(`Натомість вони перетворюються на деякі `, figurative(`іменовані`), ` об'єкти, до яких можна звертатись через ідентифікатори. `),
                sentence(`Оголошення і визначення цих об'єктів залишається `, figurative(`за кадром`), `, але робота з ідентифікаторами що на них посилаються нічим не відрізняється від роботи з будь-якими іншими ідентифікаторами. `),
                sentence(`Таким чином стає можливе створення змінних з відповідними іменами, оскільки ідентифікатори можна перекривати. `),
                sentence(`Недоліком тут може виступати реалізація перекриття для конкретної мови, але це вже окрема історія. `),
                sentence(`Також варто зауважити що при цьому службові слова можуть повністю зберігати виключний для себе синтаксис і навіть мати спеціальні типи. `),
            ]),
            [
                code_11,
                code_12,
                code_13,
            ],
            paragraph(...[
                sentence(`Такий підхід робить можливим налаштування мови під конкретного користувача. `),
                sentence(`Наприклад, можливе перейменовування службових слів відповідно до певних погоджень. `),
                sentence(`Можна починати їх з префіксу `, code_12, `, записувати у верхньому регістрі, або ж скорочувати `, code_11, ` чи навіть розширювати `, code_13, ` їхні назви для зручності. `),
                sentence(`Це також може спростити процес переносу коду з однієї мови на іншу. `),
                sentence(`Але найважливішим тут залишається те, що усе це робиться без втручань в ядро мови, для конкретного проекту, бібліотеки чи навіть окремої функції. `),
            ]),
        ]),
        section(`Підсумки`, ...[
            paragraph(...[
                sentence(`Сучасний підхід до роботи зі службовими словами все ще є куди розвивати. `),
                sentence(`Це допомогло б з вирішенням хоч і не суттєвих, але цілком реальних проблем. `),
                sentence(`Окрім цього, чітке відділення їхнього синтаксису від синтаксису ідентифікаторів вже має приклади реалізації в існуючих мовах. `),
                sentence(`Реалізація ж змішаного підходу могла б стати щонайменше предметом перспективного дослідження. `),
            ]),
        ]),
    ),
});
