const hosting = require(`../server/hosting`);
const documenting = require(`../server/documenting`);


const h = hosting;
const s = documenting.shortcuts;
const {
    document,
    section,
    paragraph,
    sentence,
    note,
    list,
    figurative,
    emphasis,
    link,
    js,
    c,
    v,
    f,
} = s;


// const code_1 = require(`./visitor/code-1`);


exports = module.exports = new h.DocumentResource({
    Document : document([ `Це можна покращити! `, `Автоматизований відвідувач в ECMAScript 6. ` ],
        {
            Date : new Date(`2019-11-01T00:00:00.000Z`),
        },
        section(``, ...[
            paragraph(...[
                sentence(`В одній з попередніх статей я розповідав про шаблон проектування відвідувач та як його можна розвинути в ECMAScript 6. `),
                sentence(`Цього разу мова піде про те як взагалі відмовитись від ручної реалізації відвідувачів автоматизувавши процес їхнього написання. `),
            ]),
        ]),
        section(`Ціна переваг.`, ...[
            paragraph(...[
                sentence(`Ідея відвідувача в тому, щоб розділити дані та алгоритми що їх обробляють. `),
                sentence(`Це допомагає знизити зв'язність окремих частин програми та ізолювати алгоритми один від одного. `),
                sentence(`Але у відвідувача є ціна: для його роботи необхідна допоміжна інфраструктура. `),
                sentence(`Її написання, тестування, зневаждення та підтримка вимагають ресурсів. `),
                sentence(`Та в ECMAScript 6 навіть з цим можна боротись. `),
                sentence(`Достатньо лише перекласти створення цієї інфраструктури на плечі комп'ютера. `),
            ]),
        ]),
        section(`Ідея.`, ...[
            paragraph(...[
                sentence(`Аби щоразу не створювати клас Visitor а також десятки методів Visit* вручну - ми вдамось до функції яка виконає за нас усю роботу. `),
                sentence(`Результат буде схожий на використання шаблонів у інших високорівневих мовах: ми передамо в нашу функцію класи які збираємось відвідувати, а вона поверне нам базовий клас BaseVisitor який ми будемо наслідувати. `),
            ]),
            paragraph(...[
                sentence(`Перша проблема з якою ми зіткнемось це іменування методів. `),
                sentence(`Вона полягає у тому що деякі класи можуть мати однакові імена і при цьому бути розташовані в різних модулях. `),
                sentence(`За таких умов нам не вдасться створити для них різні методи Visit*. `),
                sentence(`Можна усунути цю проблему за рахунок використання символів в якості ключів. `),
                sentence(`Символи будуть створюватись функцією CreateVisitor а доступ до них буде надаватись через статичний метод BaseVisitor.GetVisitKey. `),
                sentence(`Таким чином щоб оголосити в похідному класі метод для відвідування класу Number нам необхідно звернутись до відповідного символу через BaseVisitor.GetVisitKey(Number). `),
            ]),
        ]),
        section(`Реалізація.`, ...[
            paragraph(...[
                sentence(`Для того, щоб усе це працювало як слід, функція CreateVisitor повинна створювати клас BaseVisitor з методом Visit, а також методами [BaseVisitor.GetVisitKey(*)], які ми будемо перевантажувати в похідному класі. `),
                sentence(`Окрім цього вона також повинна розширювати прототипи відвідуваних класів таким чином, щоб вони скеровували виклик BaseVisitor.Visit до методу що відповідає їхньому класу. `),
                sentence(`За аналогією з методами [BaseVisitor.GetVisitKey(*)] можна замінити на символ й характерний для цього шаблону метод Accept. `),
                sentence(`Це робиться для того щоб відвідувані класи не ризикували втратити його через перекриття. `),
            ]),
            paragraph(...[
                sentence(`Visit під час виклику буде передавати керування методу під ключем-символом accept який реалізований в кожному з класів targets. `),
                sentence(`Той, в свою чергу, буде передавати керування назад в BaseVisitor, одному з методів під ключем-символом з колекції targetsKeys. `),
                sentence(`Кожен з цих методів можна замістити в класі похідному від BaseVisitor, таким чином виконуючи якусь корисну роботу над конкретним класом. `),
            ]),
        ]),
        section(`Це можна покращити!`, ...[
            paragraph(...[
                sentence(`Тепер, коли CreateVisitor створює за нас базовий клас та допоміжні методи - можна подумати і про зручність. `),
                sentence(`Зокрема, продовжуючи ідеї з попередньої статті можна додати додаткові аргументи в BaseVisitor.Visit. `),
                sentence(`Також знадобляться методи BaseVisitor.VisitOther та BaseVisitor.VisitUnspecified для роботи з класами що не згадані в похідному відвідувачі або взагалі відсутні у списку відвідуваних відповідно. `),
            ]),
        ]),
        section(`Прибирання зайвого.`, ...[
            paragraph(...[
                sentence(`Довгі імена функцій на кшталт CreateVisitor або BaseVisitor.GetVisitKey можливо добре підходять для пояснення коду в статті, але не завжди зручні на практиці. `),
                sentence(`Також, оскільки наша функція повертає клас, є сенс зробити її схожою на шаблони з мов C# або C++. `),
                sentence(`Зважаючи на це можна замінити деякі назви, зокрема: `),
            ]),
            list(...[
                sentence(`CreateVisitor(...targets) на Visitor(...targets). `),
                sentence(`BaseVisitor.GetVisitKey(target) на BaseVisitor.Visit(target). `),
                sentence(`BaseVisitor.VisitOther та BaseVisitor.VisitUnspecified на BaseVisitor.Visit.Other та BaseVisitor.Visit.Unspecified відповідно (для однорідності). `),
            ]),
            paragraph(...[
                sentence(`Таким чином кінцевий приклад використання функції Visitor може виглядати наступним чином: `),
            ]),
        ]),
        section(`Підсумок.`, ...[
            paragraph(...[
                sentence(`Описана тут функція може бути корисною при частому використанні шаблону відвідувач. `),
                sentence(`Її застосування усуває необхідність створювати допоміжні класи та методи вручну, а разом з ними і їх тестування та підтримку. `),
                sentence(`Також особливості її реалізації дозволяють змішувати у відвідувачі класи взагалі не пов'язані ієрархією, що особливо зручно зважаючи на відсутність множинного наслідування в JS. `),
            ]),
        ]),
    ),
});
