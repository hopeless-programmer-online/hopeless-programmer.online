const hosting = require(`../server/hosting`);
const documenting = require(`../server/documenting`);
const { illustration } = require("../server/documenting/shortcuts");


const h = hosting;
const s = documenting.shortcuts;
const {
    document,
    section,
    paragraph,
    sentence,
    note,
    list,
    figurative,
    emphasis,
    link,
    js,
    c,
    v,
    f,
} = s;


const code_1 = illustration(`...`, ...[
    js(...[
        [ `const BaseVisitor = CreateVisitor(Boolean, Number, String);` ],
        [ `` ],
        [ `class MyVisitor extends BaseVisitor {` ],
        [ `    VisitBoolean(boolean) {` ],
        [ `        return \`this is boolean: \${boolean}\`;` ],
        [ `    }` ],
        [ `    VisitNumber(number) {` ],
        [ `        return \`this is number: \${number}\`;` ],
        [ `    }` ],
        [ `    VisitString(string) {` ],
        [ `        return \`this is string: \${string}\`;` ],
        [ `    }` ],
        [ `}` ],
        [ `const myVisitor = new MyVisitor();` ],
        [ `` ],
        [ `console.log(myVisitor.Visit(5)); // this is number: 5` ],
    ]),
]);
const code_2 = illustration(`...`, ...[
    js(...[
        [ `const BaseVisitor = CreateVisitor(Boolean, Number, String);` ],
        [ `` ],
        [ `class DerivedVisitor extends BaseVisitor {` ],
        [ `    [BaseVisitor.GetVisitKey(Boolean)](boolean) {` ],
        [ `        return \`this is boolean: \${boolean}\`;` ],
        [ `    }` ],
        [ `    [BaseVisitor.GetVisitKey(Number)](number) {` ],
        [ `        return \`this is number: \${number}\`;` ],
        [ `    }` ],
        [ `    [BaseVisitor.GetVisitKey(String)](string) {` ],
        [ `        return \`this is string: \${string}\`;` ],
        [ `    }` ],
        [ `}` ],
        [ `` ],
        [ `const visitor = new DerivedVisitor();` ],
        [ `` ],
        [ `console.log(visitor.Visit(5)); // "this is number: 5"` ],
    ]),
]);
const code_3 = illustration(`...`, ...[
    js(...[
        [ `function CreateVisitor(...targets) {` ],
        [ `    // створюємо кляч для методу який відіграватиме роль accept` ],
        [ `    const accept = Symbol();` ],
        [ `    // створюємо ключ для кожного класу який ми збираємось відвідувати` ],
        [ `    const targetsKeys = new Map(targets.map(target => [ target, Symbol() ]));` ],
        [ `` ],
        [ `    // створюємо базовий клас відвідувач який буде перевантажено в майбутньому` ],
        [ `    class BaseVisitor {` ],
        [ `        static GetVisitKey(target) {` ],
        [ `            return targetKeys.get(target);` ],
        [ `        }` ],
        [ `` ],
        [ `        Visit(something) {` ],
        [ `            // метод something[accept] перенаправить виклик у інший метод цього класу` ],
        [ `            return something[accept](this);` ],
        [ `        }` ],
        [ `    }` ],
        [ `` ],
        [ `    for (const [ target, key ] of targetsKeys) {` ],
        [ `        // додаємо до відвідуваних класів метод для перенаправлення` ],
        [ `        target.prototype[accept] = function (visitor) {` ],
        [ `            // тут викликається той метод з BaseVisitor який відповідає типу target` ],
        [ `            return visitor[key](this);` ],
        [ `        }` ],
        [ `` ],
        [ `        // додаємо порожній метод до якого буде перенаправлено виклик з BaseVisitor.Visit` ],
        [ `        BaseVisitor.prototype[key] = function() {` ],
        [ `        }` ],
        [ `    }` ],
        [ `` ],
        [ `    return BaseVisitor;` ],
        [ `}` ],
    ]),
]);
const code_4 = illustration(`...`, ...[
    js(...[
        [ `function CreateVisitor(...targets) {` ],
        [ `    // створюємо кляч для методу який відіграватиме роль accept` ],
        [ `    const accept = Symbol();` ],
        [ `    // створюємо ключ для кожного класу який ми збираємось відвідувати` ],
        [ `    const targetsKeys = new Map(targets.map(target => [ target, Symbol() ]));` ],
        [ `    const visitOtherKey = Symbol();` ],
        [ `    const visitUnspecifiedKey = Symbol();` ],
        [ `` ],
        [ `    // створюємо базовий клас відвідувач який буде перевантажено в майбутньому` ],
        [ `    class BaseVisitor {` ],
        [ `        static get VisitOtherKey() {` ],
        [ `            return visitOtherKey;` ],
        [ `        }` ],
        [ `        static get VisitUnspecifiedKey() {` ],
        [ `            return visitUnspecifiedKey;` ],
        [ `        }` ],
        [ `` ],
        [ `        static GetVisitKey(target) {` ],
        [ `            return targetKeys.get(target);` ],
        [ `        }` ],
        [ `` ],
        [ `        Visit(something, ...other) {` ],
        [ `            // метод something[accept] перенаправить виклик у інший метод цього класу` ],
        [ `            return something[accept](this, ...other);` ],
        [ `        }` ],
        [ `    }` ],
        [ `` ],
        [ `    for (const [ target, key ] of targetsKeys) {` ],
        [ `        // додаємо до відвідуваних класів метод для перенаправлення` ],
        [ `        target.prototype[accept] = function (visitor, ...other) {` ],
        [ `            // тут викликається той метод з BaseVisitor який відповідає типу target` ],
        [ `            return visitor[key](this, ...other);` ],
        [ `        }` ],
        [ `` ],
        [ `        // додаємо порожній метод до якого буде перенаправлено виклик з BaseVisitor.Visit` ],
        [ `        BaseVisitor.prototype[key] = function() {` ],
        [ `            // якщо метод не заміщено то виклик скеровується в visitOtherKey` ],
        [ `            return this[visitOtherKey]();` ],
        [ `        }` ],
        [ `    }` ],
        [ `` ],
        [ `    // об'єкти які не вказані в targets будуть спрямовувати виклик в visitUnspecifiedKey` ],
        [ `    Object.prototype[accept] = function(visitor, ...other) {` ],
        [ `        return visitor[visitUnspecifiedKey](this, ...other);` ],
        [ `    }` ],
        [ `` ],
        [ `    return BaseVisitor;` ],
        [ `}` ],
    ]),
]);
const code_5 = illustration(`...`, ...[
    js(...[
        [ `const ObjectsVisitor = Visitor(Boolean, Number, String, Object, Array);` ],
        [ `` ],
        [ `class XMLSerializer extends ObjectsVisitor {` ],
        [ `    Serialize(object) {` ],
        [ `        return this.Visit(object);` ],
        [ `    }` ],
        [ `` ],
        [ `    [ObjectsVisitor.Visit(Boolean)](boolean) {` ],
        [ `        return \`<boolean>\${boolean}</boolean>\`;` ],
        [ `    }` ],
        [ `    [ObjectsVisitor.Visit(Number)](number) {` ],
        [ `        return \`<number>\${number}</number>\`;` ],
        [ `    }` ],
        [ `    [ObjectsVisitor.Visit(String)](string) {` ],
        [ `        return \`<string>\${string}</string>\`;` ],
        [ `    }` ],
        [ `    [ObjectsVisitor.Visit.Other](object) {` ],
        [ `        return \`<object/>\`;` ],
        [ `    }` ],
        [ `    [ObjectsVisitor.Visit.Unspecified](unspecified) {` ],
        [ `        return \`<unspecified/>\`;` ],
        [ `    }` ],
        [ `}` ],
        [ `` ],
        [ `const serializer = new XMLSerializer();` ],
        [ `` ],
        [ `console.log(serializer.Serialize(5)); // "<number>5</number>"` ],
    ]),
]);


exports = module.exports = new h.DocumentResource({
    Document : document([ `Це можна покращити! `, `Автоматизований відвідувач в ECMAScript 6. ` ],
        {
            Date : new Date(`2019-11-01T00:00:00.000Z`),
        },
        section(``, ...[
            paragraph(...[
                sentence(`В одній з попередніх статей я розповідав про шаблон проектування відвідувач та як його можна розвинути в ECMAScript 6. `),
                sentence(`Цього разу мова піде про те як взагалі відмовитись від ручної реалізації відвідувачів автоматизувавши процес їхнього написання. `),
            ]),
        ]),
        section(`Ціна переваг.`, ...[
            paragraph(...[
                sentence(`Ідея відвідувача в тому, щоб розділити дані та алгоритми що їх обробляють. `),
                sentence(`Це допомагає знизити зв'язність окремих частин програми та ізолювати алгоритми один від одного. `),
                sentence(`Але у відвідувача є ціна: для його роботи необхідна допоміжна інфраструктура. `),
                sentence(`Її написання, тестування, зневаждення та підтримка вимагають ресурсів. `),
                sentence(`Та в ECMAScript 6 навіть з цим можна боротись. `),
                sentence(`Достатньо лише перекласти створення цієї інфраструктури на плечі комп'ютера. `),
            ]),
        ]),
        section(`Ідея.`, ...[
            paragraph(...[
                sentence(`Аби щоразу не створювати клас Visitor а також десятки методів Visit* вручну - ми вдамось до функції яка виконає за нас усю роботу. `),
                sentence(`Результат буде схожий на використання шаблонів у інших високорівневих мовах: ми передамо в нашу функцію класи які збираємось відвідувати, а вона поверне нам базовий клас BaseVisitor який ми будемо наслідувати `, code_1, `. `),
            ]),
            code_1,
            paragraph(...[
                sentence(`Перша проблема з якою ми зіткнемось це іменування методів. `),
                sentence(`Вона полягає у тому що деякі класи можуть мати однакові імена і при цьому бути розташовані в різних модулях. `),
                sentence(`За таких умов нам не вдасться створити для них різні методи Visit*. `),
                sentence(`Можна усунути цю проблему за рахунок використання символів в якості ключів. `),
                sentence(`Символи будуть створюватись функцією CreateVisitor а доступ до них буде надаватись через статичний метод BaseVisitor.GetVisitKey `, code_2, `. `),
                sentence(`Таким чином щоб оголосити в похідному класі метод для відвідування класу Number нам необхідно звернутись до відповідного символу через BaseVisitor.GetVisitKey(Number). `),
            ]),
            code_2,
        ]),
        section(`Реалізація.`, ...[
            paragraph(...[
                sentence(`Для того, щоб усе це працювало як слід, функція CreateVisitor повинна створювати клас BaseVisitor з методом Visit, а також методами [BaseVisitor.GetVisitKey(*)], які ми будемо перевантажувати в похідному класі. `),
                sentence(`Окрім цього вона також повинна розширювати прототипи відвідуваних класів таким чином, щоб вони скеровували виклик BaseVisitor.Visit до методу що відповідає їхньому класу `, code_3, `. `),
                sentence(`За аналогією з методами [BaseVisitor.GetVisitKey(*)] можна замінити на символ й характерний для цього шаблону метод Accept. `),
                sentence(`Це робиться для того щоб відвідувані класи не ризикували втратити його через перекриття. `),
            ]),
            code_3,
            paragraph(...[
                sentence(`Visit під час виклику буде передавати керування методу під ключем-символом accept який реалізований в кожному з класів targets. `),
                sentence(`Той, в свою чергу, буде передавати керування назад в BaseVisitor, одному з методів під ключем-символом з колекції targetsKeys. `),
                sentence(`Кожен з цих методів можна замістити в класі похідному від BaseVisitor, таким чином виконуючи якусь корисну роботу над конкретним класом. `),
            ]),
        ]),
        section(`Це можна покращити!`, ...[
            paragraph(...[
                sentence(`Тепер, коли CreateVisitor створює за нас базовий клас та допоміжні методи - можна подумати і про зручність. `),
                sentence(`Зокрема, продовжуючи ідеї з попередньої статті можна додати додаткові аргументи в BaseVisitor.Visit. `),
                sentence(`Також знадобляться методи BaseVisitor.VisitOther та BaseVisitor.VisitUnspecified для роботи з класами що не згадані в похідному відвідувачі або взагалі відсутні у списку відвідуваних відповідно `, code_4, `. `),
            ]),
            code_4,
        ]),
        section(`Прибирання зайвого.`, ...[
            paragraph(...[
                sentence(`Довгі імена функцій на кшталт CreateVisitor або BaseVisitor.GetVisitKey можливо добре підходять для пояснення коду в статті, але не завжди зручні на практиці. `),
                sentence(`Також, оскільки наша функція повертає клас, є сенс зробити її схожою на шаблони з мов C# або C++. `),
                sentence(`Зважаючи на це можна замінити деякі назви, зокрема: `),
            ]),
            list(...[
                sentence(`CreateVisitor(...targets) на Visitor(...targets). `),
                sentence(`BaseVisitor.GetVisitKey(target) на BaseVisitor.Visit(target). `),
                sentence(`BaseVisitor.VisitOther та BaseVisitor.VisitUnspecified на BaseVisitor.Visit.Other та BaseVisitor.Visit.Unspecified відповідно (для однорідності). `),
            ]),
            paragraph(...[
                sentence(`Таким чином кінцевий приклад використання функції Visitor може виглядати наступним чином: `),
            ]),
            code_5,
        ]),
        section(`Підсумок.`, ...[
            paragraph(...[
                sentence(`Описана тут функція може бути корисною при частому використанні шаблону відвідувач. `),
                sentence(`Її застосування усуває необхідність створювати допоміжні класи та методи вручну, а разом з ними і їх тестування та підтримку. `),
                sentence(`Також особливості її реалізації дозволяють змішувати у відвідувачі класи взагалі не пов'язані ієрархією, що особливо зручно зважаючи на відсутність множинного наслідування в JS. `),
            ]),
        ]),
    ),
});
